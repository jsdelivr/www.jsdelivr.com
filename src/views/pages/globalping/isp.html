<link rel="ractive" href="../../r-page-globalping.html" name="r-page">
<link rel="ractive" href="../../components/gp-header.html" name="c-gp-header">
<link rel="ractive" href="../../components/google-maps.html" name="c-google-maps">
<link rel="ractive" href="../../components/gp-footer.html" name="c-gp-footer">
<link rel="ractive" href="../../components/notification.html" name="c-notification">
<link rel="ractive" href="../../components/controlled-input.html" name="c-controlled-input">

<r-page noYield="{{noYield}}" title="{{title}}" description="{{description}}">
	<c-notification></c-notification>

	<c-gp-header additionalClasses="header-with-globalping-bg"></c-gp-header>

	<div class="p-globalping-isp">
		<div class="p-globalping-isp_head">
			<h1 class="p-globalping-isp_head_title">Looking Glass - Orange Polska</h1>

			<span class="p-globalping-isp_head_asn">AS37754</span>
		</div>

		<div class="p-globalping-isp_network">
			<div class="p-globalping-isp_network_head">
				<span>Network</span>

				<img width="32"
					height="32"
					src="{{@shared.assetsHost}}/img/globalping/link-icon.svg"
					loading="lazy"
					as-tooltip="'TODO: LOGO TITLE'">
			</div>

			<div class="p-globalping-isp_network_body">
				<div class="gp_dropdown_reg p-globalping-isp_network_body_select">
					<span>Location</span>

					<div class="btn-group">
						<button type="button"
							class="dropdown-toggle"
							data-toggle="dropdown"
							aria-haspopup="true"
							aria-expanded="false">
							<span>{{~/location}}</span>
							<i class="fa fa-angle-down" aria-hidden="true"></i>
						</button>

						<div class="dropdown-menu">
							{{#each ~/locationsList}}
								<div on-click="@this.setLocation(this)">{{this}}</div>
							{{/each}}
						</div>
					</div>
				</div>

				<c-controlled-input
					id="ipAddress"
					value="TODO: value"
					error=""
					placeholder="TODO: placeholer"
					labelText="Your IP"
					classList="p-globalping-isp_network_body_input gp_input">
				</c-controlled-input>
			</div>
		</div>

		<div class="p-globalping-isp_network-tests">
			<div class="p-globalping-isp_network_head">
				<span>Network tests</span>
			</div>

			<div class="p-globalping-isp_network-tests_body">
				<c-controlled-input
					id="ipOrHostname"
					value="TODO: value"
					error=""
					placeholder="TODO: placeholer"
					labelText="IP or Hostname"
					classList="p-globalping-isp_network-tests_body_input gp_input">
				</c-controlled-input>

				<div class="gp_dropdown_reg p-globalping-isp_network-tests_body_select">
					<span>Method</span>

					<div class="btn-group">
						<button type="button"
							class="dropdown-toggle"
							data-toggle="dropdown"
							aria-haspopup="true"
							aria-expanded="false">
							<span>{{~/testType}}</span>
							<i class="fa fa-angle-down" aria-hidden="true"></i>
						</button>

						<div class="dropdown-menu">
							{{#each ~/testTypesList}}
								<div on-click="@this.setTestType(this)">{{this}}</div>
							{{/each}}
						</div>
					</div>
				</div>

				<button type="button" class="gp_btn_green p-globalping-isp_network-tests_body_btn-test">Run Test</button>
			</div>

			<div class="p-globalping-isp_network-tests_descr">
				<span class="p-globalping-isp_network-tests_descr_msg">
					Enter a target and click <span class="highlighted">"Run Test"</span> to start a network test from:
					<br/>
					<span class="highlighted">Warsaw, Poland</span> with <span class="highlighted">Orange Polska</span>.
				</span>
			</div>
		</div>
	</div>

	<c-gp-footer></c-gp-footer>
</r-page>

<script>
	const tooltip = require('../../../assets/js/decorators/tooltip');
	const http = require('../../../assets/js/utils/http');

	component.exports = {
		data () {
			return {
				title: '',
				description: '',
				locationsList: [ 'TODO 1', 'TODO 2', 'TODO 3', 'TODO 4', 'TODO 5' ],
				location: null,
				testType: null,
				testTypesList: [ 'ping', 'ping6', 'traceroute', 'DNS', 'MTR', 'HTTP' ],
				probesResponse: null,
				probesParsed: false,
			}
		},
		onconfig () {
			if (!Ractive.isServer) {
				const ispName = this.get('ispName');

				this.set('title', `${ispName} - Globalping`);
				this.set('description', `${ispName} - Globalping`);
			}
		},
		oninit () {
			if (!Ractive.isServer) {

			}
		},
		onrender () {
			if (!Ractive.isServer) {

			}
		},
		setLocation (newLocation) {
			this.set('location', newLocation);
		},
		setTestType (newTestType) {
			this.set('testType', newTestType);
		},
		handleProbesResponse (isStored) {
			return (response) => {
				if (!isStored) {
					sessionStorage.setItem('probesResponse', JSON.stringify(response));
				} else {
					response = JSON.parse(response);
				}

				this.set('parsedLocations', this.parseProbesResponse(response));
				this.set('totalProbesCnt', response.length);
				this.set('probesParsed', true);
			};
		},
		getGlobalpingProbesData () {
			// get probes from sessionStorage or fetch them
			if (has.sessionStorage()) {
				let probesResponse = sessionStorage.getItem('probesResponse');

				if (probesResponse) {
					this.handleProbesResponse(true)(probesResponse);
				} else {
					http.fetchGlobalpingProbes().then(this.handleProbesResponse(false));
				}
			} else {
				http.fetchGlobalpingProbes().then(this.handleProbesResponse(false));
			}
		},
		parseProbesResponse (data) {
			return data.reduce((res, { location }) => {
				let cityNameLC = location.city.toLowerCase();
				let cityNameAsUrlPart = cityNameLC.split(' ').join('-');
				let countryCodeLC = location.country.toLowerCase();
				let countryNameLC = countries.find(i => i.code.toLowerCase() === countryCodeLC).name.toLowerCase();
				let countryNameAsUrlPart = countryNameLC.split(' ').join('-');
				let asnName = `as${location.asn}`;
				let networkNameAsKey = location.network.replace(/\./g, '').replace(/[\W]|_/g, ' ').replace(/\s\s+|_/g, ' ').trim().split(' ').join('-').toLowerCase();
				let continentCodeLC = location.continent.toLowerCase();
				let continentNameLC = continents.find(i => i.code.toLowerCase() === continentCodeLC).name.toLowerCase();
				let continentNameAsUrlPart = continentNameLC.split(' ').join('-');
				let regionNameLC = location.region.toLowerCase();
				let regionNameAsUrlPart = regionNameLC.split(' ').join('-');
				let stateCodeLC = location.state ? location.state.toLowerCase() : null;
				let stateNameLC = stateCodeLC ? usaStates.find(i => i.code.toLowerCase() === stateCodeLC).name.toLowerCase() : null;
				let stateNameAsUrlPart = stateNameLC ? stateNameLC.split(' ').join('-') : null;

				// collect uniques cities and count amount of probes per city
				if (!Object.keys(res.cities).includes(cityNameAsUrlPart)) {
					res.cities[cityNameAsUrlPart] = {
						name: cityNameLC,
						from: countries.find(i => i.code.toLowerCase() === countryCodeLC).name.toLowerCase(),
						probesCnt: 1,
						fromAsUrlPart: countryNameAsUrlPart,
					};
				} else {
					res.cities[cityNameAsUrlPart].probesCnt += 1;
				}

				// collect uniques ASNs and count amount of probes per ASN
				if (!Object.keys(res.asns).includes(asnName)) {
					res.asns[asnName] = {
						name: asnName,
						from: 'world',
						probesCnt: 1,
						fromAsUrlPart: 'world',
					};
				} else {
					res.asns[asnName].probesCnt += 1;
				}

				// collect uniques Networks and count amount of probes per Network
				if (!Object.keys(res.networks).includes(networkNameAsKey)) {
					res.networks[networkNameAsKey] = {
						name: location.network,
						from: 'world',
						probesCnt: 1,
						fromAsUrlPart: 'world',
					};
				} else {
					res.networks[networkNameAsKey].probesCnt += 1;
				}

				// collect uniques Countries and count amount of probes per Country
				if (!Object.keys(res.countries).includes(countryNameAsUrlPart)) {
					res.countries[countryNameAsUrlPart] = {
						name: countryNameLC,
						from: continentNameLC,
						probesCnt: 1,
						fromAsUrlPart: continentNameAsUrlPart,
					};
				} else {
					res.countries[countryNameAsUrlPart].probesCnt += 1;
				}

				// collect uniques Continents and count amount of probes per Continent
				if (!Object.keys(res.continents).includes(continentNameAsUrlPart)) {
					res.continents[continentNameAsUrlPart] = {
						name: continentNameLC,
						from: 'world',
						probesCnt: 1,
						fromAsUrlPart: 'world',
					};
				} else {
					res.continents[continentNameAsUrlPart].probesCnt += 1;
				}

				// collect uniques Regions and count amount of probes per Region
				if (!Object.keys(res.regions).includes(regionNameAsUrlPart)) {
					res.regions[regionNameAsUrlPart] = {
						name: regionNameLC,
						from: 'world',
						probesCnt: 1,
						fromAsUrlPart: 'world',
					};
				} else {
					res.regions[regionNameAsUrlPart].probesCnt += 1;
				}

				// collect uniques states (if they are present) and count amount of probes per state
				if (stateNameAsUrlPart) {
					if (!Object.keys(res.states).includes(stateNameAsUrlPart)) {
						res.states[stateNameAsUrlPart] = {
							name: stateNameLC,
							from: countries.find(i => i.code.toLowerCase() === countryCodeLC).name.toLowerCase(),
							probesCnt: 1,
							fromAsUrlPart: countryNameAsUrlPart,
						};
					} else {
						res.states[stateNameAsUrlPart].probesCnt += 1;
					}
				}

				return res;
			}, {
				cities: {},
				asns: {},
				networks: {},
				countries: {},
				continents: {},
				regions: {},
				states: {},
			});
		},
	};
</script>
