<link rel="ractive" href="../../r-page-globalping.html" name="r-page">
<link rel="ractive" href="../../components/gp-header.html" name="c-gp-header">
<link rel="ractive" href="../../components/gp-footer.html" name="c-gp-footer">
<link rel="ractive" href="../../components/notification.html" name="c-notification">
<link rel="ractive" href="../../components/controlled-input.html" name="c-controlled-input">
<link rel="ractive" href="../../components/location-input.html" name="c-location-input">
<link rel="ractive" href="../../components/controlled-textarea.html" name="c-controlled-textarea">
<link rel="ractive" href="../../components/tags-input.html" name="c-tags-input">
<link rel="ractive" href="../../components/gp-results-controls.html" name="c-gp-results-controls">
<link rel="ractive" href="../../components/gp-results-raw-output.html" name="c-gp-results-raw-output">
<link rel="ractive" href="../../components/gp-results-table-output.html" name="c-gp-results-table-output">
<link rel="ractive" href="../../components/gp-results-share.html" name="c-gp-results-share">
<link rel="ractive" href="../../components/gp-credits-message.html" name="c-gp-credits-message">
<link rel="ractive" href="../../components/gp-credits.html" name="c-gp-credits">
<link rel="ractive" href="../../components/gp-jumbotron.html" name="c-gp-jumbotron">

<r-page
	noYield="{{noYield}}"
	title="{{title}}"
	description="{{description}}"
	ogTitle="{{ogTitle}}"
	ogDescription="{{ogDescription}}"
	openGraphImage="{{#if measurement}}{{@shared.serverHost}}/open-graph/image/measurement/{{measurement}}{{/if}}"
>
	<script src="https://cdn.jsdelivr.net/npm/@googlemaps/markerclusterer@2.5.3/dist/index.umd.min.js"></script>

	{{#if !@shared.isServer && !@shared.googleMapsLoaded}}
		<script>
			function onDocumentReady (fn) {
				if (document.readyState !== 'loading') {
					fn();
				} else {
					document.addEventListener('DOMContentLoaded', fn);
				}
			}
			/* eslint-disable */
			function initMap () {
				onDocumentReady(function () {
					app.loaded = true;

					if (app.router.route && app.router.route.view && app.router.route.view.initMap) {
						app.router.route.view.initMap();
					}
				});
			}
		</script>
		<script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyBTICLY5LgWNJ0Uly61Q1sNXz_1KZIECwg&amp;language=en&amp;callback=initMap&libraries=marker&loading=async" async></script>
	{{/if}}

	<c-notification></c-notification>

	<c-gp-header additionalClasses="header-with-globalping-bg"></c-gp-header>

	<div class="p-globalping">
		<c-gp-jumbotron className="main" gridType="type1"></c-gp-jumbotron>

		<div class="gp_main-info">
			<div class="gp_main-info_descr">
				<span class="gp_main-info_descr_green">Monitor, debug and benchmark</span>
				<span>your internet infrastructure from a globally distributed network of probes.</span>
			</div>

			<div class="gp_main-info_stats">
				<div class="gp_main-info_stats_item">
					<span class="gp_main-info_stats_item_number">
						{{ Math.floor(totalProbes) }}
						<span></span>
					</span>
					<span class="gp_main-info_stats_item_text">connected probes</span>
				</div>

				<div class="gp_main-info_stats_item">
					<span class="gp_main-info_stats_item_number">
						{{ Math.floor(totalCities) }}
						<span></span>
					</span>
					<span class="gp_main-info_stats_item_text">different cities</span>
				</div>

				<div class="gp_main-info_stats_item">
					<span class="gp_main-info_stats_item_number">
						{{ Math.floor(totalCountries) }}
						<span></span>
					</span>
					<span class="gp_main-info_stats_item_text">different countries</span>
				</div>
			</div>
		</div>

		<div class="gp_map-block">
			<div class="gp_map-block_header">
				<span></span>
				<span></span>
				<span></span>
				{{#if shareResHeaderData}}
					<span class="gp_map-block_header_share-res-msg">{{shareResHeaderData}}</span>
				{{/if}}
			</div>

			<div class="gp_map-block_settings-wrapper">
				<div class="gp_map-block_settings-wrapper_settings">
					<div class="gp_map-block_settings-wrapper_settings_grouped">
						<div class="gp_dropdown_reg">
							<span>Test type</span>

							<div class="btn-group">
								<button type="button"
									class="dropdown-toggle {{#if testInProgress}}disabled{{/if}}"
									data-toggle="dropdown"
									aria-haspopup="true"
									aria-expanded="false">
									<span>{{~/mainOptions.type}}</span>
									<i class="fa fa-angle-down" aria-hidden="true"></i>
								</button>

								<div class="dropdown-menu">
									{{#each ~/testTypesList}}
										<div on-click="@this.setMainOptsTestType(this)">{{this}}</div>
									{{/each}}
								</div>
							</div>
						</div>

						<c-tags-input
							inputId="targetInput"
							value="{{mainOptions.target}}"
							defaultValue="{{DEFAULT_TARGET_VALUE}}"
							error="{{inputErrors.target}}"
							placeholder="IP or domain"
							labelText="Target(s)"
							isDisabled="{{testInProgress}}"
							setDefaultValueInitialy="{{!shareResFlow}}"
							useGpTargetHandler="{{true}}"
							gpMainOpts="{{mainOptions}}"
							gpHttpOpts="{{httpOpts}}"
							gpNotAppliedOpts="{{notAppliedOpts}}"
							gpUrlHandlerCb="{{@this.applyOptions}}"
							showIPSwitch="{{mainOptions.type !== 'DNS'}}"
							ipVersion="{{mainOptions.ipVersion}}"
							ttPos="{{ttPositions.targetTtPos}}">
							{{#partial labelIcon}}
								<img as-tooltip="'Up to 2 IP addresses or domains', ttPos"
									width="14"
									height="14"
									src="{{@shared.assetsHost}}/img/globalping/help-icon.svg">
							{{/partial}}
						</c-tags-input>
					</div>

					<div class="gp_map-block_settings-wrapper_settings_grouped">
						<c-location-input
							on-enter="@this.resetMapAndRunTest()"
							rawProbes="{{rawProbes}}"
							value="{{mainOptions.location}}"
							error="{{inputErrors.location}}"
							placeholder="Enter location"
							labelText="Location"
							classList="gp_map-block_settings-wrapper_settings_location gp_input"
							disabled="{{testInProgress}}"
							ttPos="{{ttPositions.locationTtPos}}">
							{{#partial labelIcon}}
								<img as-tooltip="[ 'This magic field supports names of continents, regions, countries, US states, cities, networks, and our custom tags.', '', 'Use + to combine multiple filters.', 'Use , to select multiple locations.' ], ttPos, undefined, undefined, 'multiline'"
									width="14"
									height="14"
									src="{{@shared.assetsHost}}/img/globalping/help-icon.svg">
							{{/partial}}
						</c-location-input>

						<div class="gp_map-block_settings-wrapper_settings_subgroup">
							<c-controlled-input
								id="limitInput"
								value="{{mainOptions.limit}}"
								error="{{inputErrors.limit}}"
								placeholder="{{defaultLimit}}"
								labelText="Limit"
								classList="gp_map-block_settings-wrapper_settings_limit gp_input"
								hideLabelIcon="{{infiniteSwitchEnabled === false}}"
								disabled="{{testInProgress}}"
								ttPos="{{ttPositions.limitTtPos}}">
								{{#partial labelIcon}}
									<img as-tooltip="'Values up to 5 are supported for infinite measurements', ttPos, undefined, undefined, 'gp_tt-limit'"
										width="14"
										height="14"
										src="{{@shared.assetsHost}}/img/globalping/help-icon.svg">
								{{/partial}}
							</c-controlled-input>

							<div class="gp_map-block_settings-wrapper_settings_subgroup_options-block {{#if testInProgress}}disabled{{/if}}">
								<button class="{{#if showMeasurementOpts}}active{{/if}}"
									on-click="@this.handleToggleMeasOpts()">
									<img width="20"
										height="20"
										src="{{@shared.assetsHost}}/img/globalping/settings-icon.svg">

									{{#if modifiedMeasOptsCnt && showMeasurementOpts === false}}
										<div class="additional-opts-total">
											{{modifiedMeasOptsCnt}}
										</div>
									{{/if}}
								</button>

								<div class="gp_map-block_settings-wrapper_settings_subgroup_options-block_specific-set">
									{{#if mainOptions.type === 'ping'}}
										<div class="typePing">
											<div class="pair">
												<c-controlled-input
													value="{{notAppliedOpts.port}}"
													error="{{inputErrors.port}}"
													placeholder="80"
													labelText="Port"
													classList="port-input gp_input"
													disabled="{{disablePort}}">
												</c-controlled-input>

												<div class="gp_dropdown_reg">
													<span>Protocol</span>

													<div class="btn-group">
														<button type="button"
																class="dropdown-toggle"
																data-toggle="dropdown"
																aria-haspopup="true"
																aria-expanded="false">
															<span>{{~/pingOpts.protocol}}</span>
															<i class="fa fa-angle-down" aria-hidden="true"></i>
														</button>

														<div class="dropdown-menu">
															<div on-click="@this.set('pingOpts.protocol', 'TCP')">TCP</div>
															<div on-click="@this.set('pingOpts.protocol', 'ICMP')">ICMP</div>
														</div>
													</div>
												</div>
											</div>

											<c-controlled-input
												value="{{notAppliedOpts.packets}}"
												error="{{inputErrors.packets}}"
												placeholder="{{defaultPacketsAmount}}"
												labelText="Packets"
												classList="gp_input"
												disabled="{{infiniteSwitchEnabled}}">
											</c-controlled-input>
										</div>
									{{/if}}

									{{#if mainOptions.type === 'traceroute'}}
										<div class="typeTraceroute">
											<div class="pair">
												<c-controlled-input
													value="{{notAppliedOpts.port}}"
													error="{{inputErrors.port}}"
													placeholder="53"
													labelText="Port"
													classList="port-input gp_input"
													disabled="{{disablePort}}">
												</c-controlled-input>

												<div class="gp_dropdown_reg">
													<span>Protocol</span>

													<div class="btn-group">
														<button type="button"
															class="dropdown-toggle"
															data-toggle="dropdown"
															aria-haspopup="true"
															aria-expanded="false">
															<span>{{~/tracerouteOpts.protocol}}</span>
															<i class="fa fa-angle-down" aria-hidden="true"></i>
														</button>

														<div class="dropdown-menu">
															<div on-click="@this.set('tracerouteOpts.protocol', 'TCP')">TCP</div>
															<div on-click="@this.set('tracerouteOpts.protocol', 'UDP')">UDP</div>
															<div on-click="@this.set('tracerouteOpts.protocol', 'ICMP')">ICMP</div>
														</div>
													</div>
												</div>
											</div>
										</div>
									{{/if}}

									{{#if mainOptions.type === 'DNS'}}
										<div class="typeDNS">
											<div class="rows">
												<div class="rows_row-one">
													<c-controlled-input
														value="{{notAppliedOpts.port}}"
														error="{{inputErrors.port}}"
														placeholder="53"
														labelText="Port"
														classList="port-input gp_input">
													</c-controlled-input>

													<div class="gp_dropdown_reg">
														<span>Protocol</span>

														<div class="btn-group">
															<button type="button"
																class="dropdown-toggle"
																data-toggle="dropdown"
																aria-haspopup="true"
																aria-expanded="false">
																<span>{{~/dnsOpts.protocol}}</span>
																<i class="fa fa-angle-down" aria-hidden="true"></i>
															</button>

															<div class="dropdown-menu">
																<div on-click="@this.set('dnsOpts.protocol', 'UDP')">UDP</div>
																<div on-click="@this.set('dnsOpts.protocol', 'TCP')">TCP</div>
															</div>
														</div>
													</div>
												</div>

												<div class="rows_row-two">
													<div class="gp_dropdown_reg">
														<span>Type</span>

														<div class="btn-group">
															<button type="button"
																class="dropdown-toggle"
																data-toggle="dropdown"
																aria-haspopup="true"
																aria-expanded="false">
																<span>{{~/dnsOpts.query.type}}</span>
																<i class="fa fa-angle-down" aria-hidden="true"></i>
															</button>

															<div class="dropdown-menu">
																{{#each ~/dnsTypesList}}
																	<div on-click="@this.set('dnsOpts.query.type', this)">{{this}}</div>
																{{/each}}
															</div>
														</div>
													</div>

													<div class="rows_row-two_switch-block">
														<label class="gp_switch">
															<input type="checkbox" on-click="@this.set('dnsOpts.trace', !dnsOpts.trace)" checked="{{dnsOpts.trace}}">
															<span class="slider round"></span>
														</label>

														<span>Trace</span>
													</div>
												</div>
											</div>

											<c-controlled-input
												value="{{notAppliedOpts.resolver}}"
												error="{{inputErrors.resolver}}"
												placeholder="IP address"
												labelText="Resolver"
												classList="resolver-input gp_input">
											</c-controlled-input>
										</div>
									{{/if}}

									{{#if mainOptions.type === 'MTR'}}
										<div class="typeMTR">
											<div class="pair">
												<c-controlled-input
													value="{{notAppliedOpts.port}}"
													error="{{inputErrors.port}}"
													placeholder="53"
													labelText="Port"
													classList="port-input gp_input"
													disabled="{{disablePort}}">
												</c-controlled-input>

												<div class="gp_dropdown_reg">
													<span>Protocol</span>

													<div class="btn-group">
														<button type="button"
															class="dropdown-toggle"
															data-toggle="dropdown"
															aria-haspopup="true"
															aria-expanded="false">
															<span>{{~/mtrOpts.protocol}}</span>
															<i class="fa fa-angle-down" aria-hidden="true"></i>
														</button>

														<div class="dropdown-menu">
															<div on-click="@this.set('mtrOpts.protocol', 'UDP')">UDP</div>
															<div on-click="@this.set('mtrOpts.protocol', 'TCP')">TCP</div>
															<div on-click="@this.set('mtrOpts.protocol', 'ICMP')">ICMP</div>
														</div>
													</div>
												</div>
											</div>

											<c-controlled-input
												value="{{notAppliedOpts.packets}}"
												error="{{inputErrors.packets}}"
												placeholder="{{defaultPacketsAmount}}"
												labelText="Packets"
												classList="gp_input">
											</c-controlled-input>
										</div>
									{{/if}}

									{{#if mainOptions.type === 'HTTP'}}
										<div class="typeHTTP">
											<c-controlled-input
												value="{{notAppliedOpts.request.host}}"
												error="{{inputErrors.host}}"
												placeholder="Host"
												labelText="Host"
												classList="gp_input">
											</c-controlled-input>

											<c-controlled-input
												value="{{notAppliedOpts.request.path}}"
												error="{{inputErrors.path}}"
												placeholder="Path"
												labelText="Path"
												classList="gp_input">
											</c-controlled-input>

											<c-controlled-input
												value="{{notAppliedOpts.request.query}}"
												error="{{inputErrors.query}}"
												placeholder="Query"
												labelText="Query"
												classList="gp_input">
											</c-controlled-input>

											<div class="pair">
												<div class="gp_dropdown_reg">
													<span>Protocol</span>

													<div class="btn-group">
														<button type="button"
															class="dropdown-toggle"
															data-toggle="dropdown"
															aria-haspopup="true"
															aria-expanded="false">
															<span>{{~/httpOpts.protocol}}</span>
															<i class="fa fa-angle-down" aria-hidden="true"></i>
														</button>

														<div class="dropdown-menu">
															<div on-click="@this.set('httpOpts.protocol', 'HTTP')">HTTP</div>
															<div on-click="@this.set('httpOpts.protocol', 'HTTPS')">HTTPS</div>
															<div on-click="@this.set('httpOpts.protocol', 'HTTP2')">HTTP2</div>
														</div>
													</div>
												</div>

												<c-controlled-input
													value="{{notAppliedOpts.port}}"
													error="{{inputErrors.port}}"
													placeholder="53"
													labelText="Port"
													classList="port-input gp_input">
												</c-controlled-input>
											</div>

											<div class="pair">
												<div class="gp_dropdown_reg">
													<span>Method</span>

													<div class="btn-group">
														<button type="button"
															class="dropdown-toggle"
															data-toggle="dropdown"
															aria-haspopup="true"
															aria-expanded="false">
															<span>{{~/httpOpts.request.method}}</span>
															<i class="fa fa-angle-down" aria-hidden="true"></i>
														</button>

														<div class="dropdown-menu">
															<div on-click="@this.set('httpOpts.request.method', 'GET')">GET</div>
															<div on-click="@this.set('httpOpts.request.method', 'HEAD')">HEAD</div>
															<div on-click="@this.set('httpOpts.request.method', 'OPTIONS')">OPTIONS</div>
														</div>
													</div>
												</div>

												<c-controlled-input
													value="{{notAppliedOpts.resolver}}"
													error="{{inputErrors.resolver}}"
													placeholder="Resolver"
													labelText="Resolver"
													classList="gp_input">
												</c-controlled-input>
											</div>

											<c-controlled-textarea
												value="{{notAppliedOpts.request.headers}}"
												error="{{inputErrors.headers}}"
												placeholder="Header: Value"
												labelText="Headers"
												classList="gp_input">
											</c-controlled-textarea>
										</div>
									{{/if}}

									<button class="gp_btn_green" on-click="@this.applyOptions()">
										Apply
									</button>
								</div>
							</div>

							<div class="gp_map-block_settings-wrapper_settings_subgroup_switch-block {{#unless @this.isInfiniteOptsCorrect()}}turned-off{{/unless}} {{#if testInProgress}}disabled{{/if}}">
								<label class="gp_switch">
									<input type="checkbox"
										checked="{{infiniteSwitchEnabled}}"
										on-click="@this.handleInfiniteSwitch()"
										on-keydown="@this.handleInfiniteSwitchKeyDown(@event)"
										{{#unless @this.isInfiniteOptsCorrect() && !testInProgress}}disabled="true"{{/unless}}>
									<span class="slider round"></span>
								</label>

								<span>Infinite</span>
							</div>
						</div>
					</div>
				</div>

				<div id="dd-run-test-btn" class="btn-group run-test-btn">
					{{#if prevProbesMeasId && !testInProgress}}
						<div class="gp_map-block_settings-wrapper_split-btn">
							<div class="gp_map-block_settings-wrapper_split-btn_run gp_btn_green" on-click="@this.resetMapAndRunTest()">
								Run
							</div>

							<button type="button"
								class="dropdown-toggle gp_btn_green"
								data-toggle="dropdown"
								aria-haspopup="true"
								aria-expanded="false">
									<div class="gp_map-block_settings-wrapper_split-btn_icon">
										<img width="20" height="20" src="{{@shared.assetsHost}}/img/icons/chevron-down.white.svg">
									</div>
							</button>

							<div class="dropdown-menu gp_map-block_settings-wrapper_split-btn_dropdown">
								<span class="dropdown-item" on-click="@this.resetMapAndRunTest()">Test</span>
								<span class="dropdown-item" on-click="@this.reUseProbesRunTest()">Re-use probes</span>
							</div>
						</div>
					{{elseif infiniteSwitchEnabled}}
						<button on-click="@this.handleInfiniteMeasBtn()"
							class="gp_map-block_settings-wrapper_btn gp_btn_green {{#if testInProgress}}gp_btn_infinite gp_btn_infinite_loading{{/if}}">
							{{#if testInProgress}}
								<span>{{runTestBtnText}}</span>
								<div class="spinner">
									<div></div>
									<div></div>
									<div></div>
									<div></div>
								</div>
							{{else}}
								{{runTestBtnText}}
							{{/if}}
						</button>
					{{else}}
						<button on-click="@this.resetMapAndRunTest()"
							class="gp_map-block_settings-wrapper_btn gp_btn_green {{#if testInProgress}}gp_btn_green_disabled gp_btn_green_loading{{/if}}"
							disabled="{{testInProgress}}">
							{{#if testInProgress}}
								<div></div>
								<div></div>
								<div></div>
								<div></div>
							{{else}}
								{{runTestBtnText}}
							{{/if}}
						</button>
					{{/if}}
				</div>
			</div>

			{{#if showCreditsError}}
				<c-gp-credits-message
					rateCreditsData="{{rateCreditsData}}">
				</c-gp-credits-message>
			{{/if}}

			<div class="gp_map-block_map-wrapper {{#unless transitionMap}}transition-none{{/unless}} {{#unless showMap}}gp_map-block_map-wrapper_hidden{{/unless}}">
				<div id="gp-map" class="gp_map-block_map-wrapper_map"></div>

				{{#if testResults}}
					<div class="gp_map-block_map-wrapper_timings-scale">
						<span class="value">{{probesMaxTiming}} ms</span>
						<div class="gradient"></div>
						<span class="value">{{probesMinTiming}} ms</span>
					</div>
				{{/if}}
			</div>

			{{#if showCreditsData}}
				{{#unless showMap}}
					<div class="gp_map-block_line"></div>
				{{/unless}}

				<c-gp-credits
					mapOpened="{{showMap}}"
					testInProgress="{{testInProgress}}"
					isInfiniteModeRes="{{isInfiniteModeRes}}"
					rateCreditsData="{{rateCreditsData}}"
					testResults="{{testResults}}">
				</c-gp-credits>

				{{#if showMap}}
					<div class="gp_map-block_line"></div>
				{{/if}}
			{{/if}}

			{{#unless showMap}}
				<div class="gp_map-block_line"></div>
			{{/unless}}

			{{#if measurementErrMsg}}
				<div class="gp_map-block_test-output with-padding">
					<div class="gp_map-block_test-output_fail-msg">
						<img width="56"
							height="56"
							src="{{@shared.assetsHost}}/img/globalping/fail-icon-big.svg">

						<p>{{{measurementErrMsg}}}</p>
					</div>
				</div>
			{{elseif testResults}}
				<div class="gp_map-block_test-output">
					<c-gp-results-controls
						showMap="{{showMap}}"
						originalShowMap="{{originalShowMap}}"
						targets="{{targetsArr}}"
						activeTargetIdx="{{activeTargetIdx}}"
						rawOutputMode="{{rawOutputMode}}"
						testType="{{testReqParams.type}}">
					</c-gp-results-controls>

					{{#if rawOutputMode}}
						<div class="gp_map-block_test-output_raw-output">
							<c-gp-results-raw-output
								testReqParams="{{testReqParams}}"
								preparedTestResults="{{preparedTestResults}}"
								testInProgress="{{testInProgress}}"
								scrolledToResIdx="{{scrolledToResIdx}}"
								currSearchLocation="{{mainOptions.location}}"
								measurementsMetadata="{{measurementsMetadata}}"
								activeTargetIdx="{{activeTargetIdx}}"
								isInfiniteModeRes="{{isInfiniteModeRes}}"
								screenWidth="{{screenWidth}}">
							</c-gp-results-raw-output>
						</div>
					{{else}}
						<div class="gp_map-block_test-output_table-output">
							<c-gp-results-table-output
								testReqParams="{{testReqParams}}"
								testInProgress="{{testInProgress}}"
								preparedTestResults="{{preparedTestResults}}"
								targetsCnt="{{targetsArr.length}}"
								currSearchLocation="{{mainOptions.location}}"
								measurementsMetadata="{{measurementsMetadata}}"
								isInfiniteModeRes="{{isInfiniteModeRes}}">
							</c-gp-results-table-output>
						</div>
					{{/if}}

					{{#if testReqParams.id && !testInProgress}}
						<c-gp-results-share
							testReqParams="{{testReqParams}}"
							measurementsMetadata="{{measurementsMetadata}}"
							isInfiniteModeRes="{{isInfiniteModeRes}}"
							testInProgress="{{testInProgress}}"
							preparedTestResults="{{preparedTestResults}}"
							activeTargetIdx="{{activeTargetIdx}}">
						</c-gp-results-share>
					{{/if}}
				</div>
			{{else}}
				<div class="gp_map-block_test-output with-padding">
					<div class="gp_map-block_test-output_info">
						<img width="56"
							height="56"
							src="{{@shared.assetsHost}}/img/globalping/bulb-icon.svg">

						<p>
							Run a global latency test! Benchmark your CDN provider and understand how the network performs!
							Compare DNS providers to find the fastest one globally or in your region.
							Run network tests globally or from specific locations and regions.
							Debug and troubleshoot your networking problems and share the test results with others!
						</p>
					</div>
				</div>
			{{/if}}
		</div>

		<div class="gp_detalization">
			<div class="gp_detalization_platform">
				<div class="gp_detalization_platform_title">The Globalping platform</div>
				<div class="gp_detalization_platform_descr">
					Globalping is a platform that allows anyone to run networking commands such as ping, traceroute,
					dig, curl and mtr on probes distributed all around the world. Our goal is to provide a free and simple
					service for everyone out there to make the internet faster. You can use it to optimize your anycast
					network, monitor your latency, debug routing issues and even check for censorship in different countries.
				</div>
				<img class="gp_detalization_platform_img"
					width="363"
					height="288"
					src="{{@shared.assetsHost}}/img/globalping/polygons_1.svg">
			</div>

			<div class="gp_detalization_magic">
				<div class="gp_detalization_magic_title">Test from anywhere with <span class="text-magic-color">magic</span></div>
				<div class="gp_detalization_magic_descr">
					All Globalping integrations and tools including the CLI <a target="_blank" href="https://github.com/jsdelivr/globalping#best-practices-and-tips">use the magic API field</a> to set the location of a test.
					This means that you can write anything that makes sense to you as the input and we will do our best to select the
					most appropriate probes. Valid inputs include countries, continents, cities, US states, regions
					(Western Europe), ASNs, ISP names, eyeball or datacenter tags and cloud region names (us-east-2).
				</div>
				<img class="gp_detalization_magic_img"
					width="510"
					height="289"
					src="{{@shared.assetsHost}}/img/globalping/polygons_2.svg">
			</div>
		</div>

		<div class="gp_features">
			<div class="gp_features_item">
				<span class="gp_features_item_icon">
					<img width="48"
						height="48"
						src="{{@shared.assetsHost}}/img/globalping/globalping-opensource-icon.svg">
				</span>
				<span class="gp_features_item_name">
					Open source and free
				</span>
				<span class="gp_features_item_descr">
					Every component of Globalping is open source and is being actively developed on GitHub with the help of our community and users. We offer generous free limits with higher limits for GitHub Sponsors.
				</span>
			</div>

			<div class="gp_features_item">
				<span class="gp_features_item_icon">
					<img width="48"
						height="48"
						src="{{@shared.assetsHost}}/img/globalping/globalping-nonprofit-icon.svg">
					</span>
				<span class="gp_features_item_name">
					Developed by jsDelivr
				</span>
				<span class="gp_features_item_descr">
					The Globalping platform is developed by the jsDelivr team who has more than 10 years of experience maintaining the jsDelivr CDN which is being used by millions of websites around the globe.
				</span>
			</div>

			<div class="gp_features_item">
				<span class="gp_features_item_icon">
					<img width="48"
						height="48"
						src="{{@shared.assetsHost}}/img/globalping/globalping-community-icon.svg">
					</span>
				<span class="gp_features_item_name">
					Powered by community and sponsors
				</span>
				<span class="gp_features_item_descr">
					The jsDelivr organization and all projects including Globalping rely on our corporate and individual sponsors. Consider joining them to help us release new features even faster!
				</span>
			</div>

			<div class="gp_features_item">
				<span class="gp_features_item_icon">
					<img width="48"
						height="48"
						src="{{@shared.assetsHost}}/img/globalping/globalping-security-icon.svg">
				</span>
				<span class="gp_features_item_name">
					Secure and private
				</span>
				<span class="gp_features_item_descr">
					The security of our systems and privacy of our users are of the utmost importance for us. We minimize the public information that our probes expose and block harmful and abusive domains and IPs.
				</span>
			</div>
		</div>

		<div class="gp_installation">
			<a href="/cli" class="gp_installation_item">
				<img width="61"
					height="53"
					src="{{@shared.assetsHost}}/img/globalping/cli-icon.svg">

				<span class="gp_installation_item_title">
					Install the Globalping CLI
				</span>

				<span class="gp_installation_item_descr">
					Run and script network tests from all over the world without ever leaving your terminal
				</span>
			</a>

			<a href="/docs/api.globalping.io" class="gp_installation_item router-ignore">
				<img width="61"
					height="53"
					src="{{@shared.assetsHost}}/img/globalping/rest-api-icon.svg">

				<span class="gp_installation_item_title">
					Integrate the Globalping REST API
				</span>

				<span class="gp_installation_item_descr">
					Use our free API to build your own tools, automated your tests and integrate Globalping into your existing flow
				</span>
			</a>

			<a href="/globalping/slack" class="gp_installation_item">
				<img width="61"
					height="53"
					src="{{@shared.assetsHost}}/img/globalping/slack-icon.svg">

				<span class="gp_installation_item_title">
					Install the Globalping Slack App
				</span>

				<span class="gp_installation_item_descr">
					Install the app into your Slack organization to allow all of your members to run global tests in any channel
				</span>
			</a>
		</div>

		<div class="gp_our-users">
			<div class="gp_our-users_title">Our users:</div>
			<div class="gp_our-users_list">
				<div class="gp_our-users_list_user">
					<a target="_blank" rel="noopener noreferrer" href="https://www.fastly.com">
						<img title="Used by Fastly"
							height="48"
							src="{{@shared.assetsHost}}/img/globalping/sponsors/fastly.png"
							srcset="{{@shared.assetsHost}}/img/globalping/sponsors/fastly@2x.png 2x"
							loading="lazy">
					</a>
				</div>

				<div class="gp_our-users_list_user">
					<a target="_blank" rel="noopener noreferrer" href="https://he.net">
						<img title="Used by Hurricane Electric"
							height="48"
							src="{{@shared.assetsHost}}/img/globalping/sponsors/hurricane_electric.png"
							loading="lazy">
					</a>
				</div>

				<div class="gp_our-users_list_user">
					<a target="_blank" rel="noopener noreferrer" href="https://www.dnsfilter.com/">
						<img title="Used by DNSFilter"
							height="48"
							src="{{@shared.assetsHost}}/img/globalping/sponsors/dnsfilter.png"
							loading="lazy">
					</a>
				</div>
			</div>
		</div>

		<div class="gp_join-network" id="join-the-network">
			<span class="gp_join-network_title">Join the network</span>
			<span class="gp_join-network_subtitle">
				To join the Globalping probe network all you have to do is run our container.
			</span>

			<div class="gp_join-network_switch-wrapper">
				<span class="gp_join-network_switch">
					<span class="{{#if joinNetSwitchValue === 'docker'}}active{{/if}}"
						on-click="@this.set('joinNetSwitchValue', 'docker')">
						Docker
					</span>
					<span class="{{#if joinNetSwitchValue === 'podman'}}active{{/if}}"
						on-click="@this.set('joinNetSwitchValue', 'podman')">
						Podman
					</span>
				</span>
			</div>

			<div class="gp_join-network_cmd-block">
				<div class="gp_join-network_cmd-block_command {{#if showCommandsBlock}}opened{{/if}}">
					{{#if showCommandsBlock}}
						{{#each netCmdTextFull:idx}}
							<div class="gp_join-network_cmd-block_command_row">
								<span>{{idx + 1}}</span>
								<span>{{this.cmd}}</span>
								{{#if this.comment}}
									<span>{{this.comment}}</span>
								{{/if}}
							</div>
						{{/each}}
					{{else}}
						<div class="gp_join-network_cmd-block_command_oneliner">
							{{netCmdText}}
						</div>
					{{/if}}
				</div>

				<button class="gp_join-network_cmd-block_btn gp_btn_green"
					as-clipboard data-clipboard-text="{{showCommandsBlock ? netCmdTextFullClipboard : netCmdText}}">
					<img width="20"
						height="20"
						src="{{@shared.assetsHost}}/img/globalping/copy-icon.svg">
				</button>

				<div class="gp_join-network_cmd-block_open-btn {{#if showCommandsBlock}}active{{/if}}"
					on-click="@this.toggle('showCommandsBlock')">
					<img width="9"
						height="6"
						src="{{@shared.assetsHost}}/img/globalping/chevron.svg">
				</div>
			</div>

			<span class="gp_join-network_descr">
				Once you connect you will become part of the global community that powers the Globalping Platform.
				The container will work on both x86 and ARM architectures.
			</span>
		</div>

		<div class="gp_join-community">
			<div class="gp_join-community_content">
				<span class="gp_join-community_content_title">
					We invite everyone to join our community and help us develop our projects.
				</span>

				<ul class="gp_join-community_content_list">
					<li>We promise a friendly discussion in our issues and code reviews</li>
					<li>We appreciate your work and will review your PRs in a timely manner</li>
					<li>We are open to new ideas and technologies</li>
					<li>You don't have to be a developer to help</li>
					<li>Copyrighters, community moderators, dev relations, media relations... are all equally important</li>
				</ul>

				<img class="gp_join-community_img"
					width="363"
					height="416"
					src="{{@shared.assetsHost}}/img/globalping/polygons_3.svg">
			</div>
		</div>

		<div class="gp_gh-links">
			<div class="gp_gh-links_header">
				<span class="gp_gh-links_header_title">Become an open source contributor!</span>

				<img width="64"
					height="64"
					src="{{@shared.assetsHost}}/img/globalping/github.svg">
			</div>

			<div class="gp_gh-links_content">
				<a target="_blank" rel="noopener noreferrer" href="https://github.com/jsdelivr/globalping" class="gp_gh-links_content_item">
					<span class="gp_gh-links_content_item_title">
						Globalping API
					</span>

					<span class="gp_gh-links_content_item_descr">
						Learn more about the project, the API, tools and become a contributor
					</span>
				</a>

				<a target="_blank" rel="noopener noreferrer" href="https://github.com/jsdelivr/globalping-cli" class="gp_gh-links_content_item">
					<span class="gp_gh-links_content_item_title">
						Globalping CLI
					</span>

					<span class="gp_gh-links_content_item_descr">
						Our simple to use CLI is also open source and awaits for your feedback.
					</span>
				</a>

				<a target="_blank" rel="noopener noreferrer" href="https://github.com/jsdelivr/globalping-probe" class="gp_gh-links_content_item">
					<span class="gp_gh-links_content_item_title">
						Globalping Probe
					</span>

					<span class="gp_gh-links_content_item_descr">
						Explore the codebase of our software probes and firmware for hardware probes as well
					</span>
				</a>
			</div>
		</div>

		<div class="gp_probe">
			<div class="gp_probe_promo">
				<img width="198"
					height="198"
					src="{{@shared.assetsHost}}/img/globalping/probe.png"
					srcset="{{@shared.assetsHost}}/img/globalping/probe@2x.png 2x">

				<div class="gp_probe_promo_content">
					<span class="gp_probe_promo_content_title">
						Get a hardware probe
					</span>

					<span class="gp_probe_promo_content_descr">
						Become a GitHub sponsor for $10/month or more and get your own hardware probe to install in your home or office network.
					</span>

					<a target="_blank" rel="noopener noreferrer" href="https://github.com/sponsors/jsdelivr" class="gp_probe_promo_content_btn gp_btn_green">
						<img width="20"
							height="20"
							src="{{@shared.assetsHost}}/img/globalping/github.small.svg">

						Become a GitHub Sponsor
					</a>
				</div>
			</div>

			<div class="gp_probe_get-probe">
				<div class="gp_probe_get-probe_header">
					How to get a probe?
				</div>

				<div class="gp_probe_get-probe_list">
					<div class="gp_probe_get-probe_list_item">
						<div class="gp_probe_get-probe_list_item_progress">
							<img width="24"
								height="24"
								src="{{@shared.assetsHost}}/img/globalping/circle-icon.svg">

							<span></span>
						</div>

						<div class="gp_probe_get-probe_list_item_content">
							<span>Become a sponsor</span>
							<span>Become a GitHub Sponsor for $10+/month.</span>
						</div>
					</div>

					<div class="gp_probe_get-probe_list_item">
						<div class="gp_probe_get-probe_list_item_progress">
							<img width="24"
								height="24"
								src="{{@shared.assetsHost}}/img/globalping/circle-icon.svg">

							<span></span>
						</div>

						<div class="gp_probe_get-probe_list_item_content">
							<span>
								<a target="_blank" rel="noopener noreferrer" href="https://forms.gle/9jSzytJpTDYJmS2W8">Fill the form</a>
							</span>
							<span>Fill out this form with your details.</span>
						</div>
					</div>

					<div class="gp_probe_get-probe_list_item">
						<div class="gp_probe_get-probe_list_item_progress">
							<img width="24"
								height="24"
								src="{{@shared.assetsHost}}/img/globalping/circle-icon.svg">
						</div>

						<div class="gp_probe_get-probe_list_item_content">
							<span>Probe arrives</span>
							<span>Wait for the probe to arrive.</span>
						</div>
					</div>
				</div>
			</div>

			<div class="gp_probe_how-it-works">
				<div class="gp_probe_how-it-works_header">How it works?</div>
				<div class="gp_probe_how-it-works_text">
					<span>
						Installing our hardware probe simplifies the whole process and <b>removes the need of having a computer running 24/7.</b>
						Just connect the probe to your switch or router via an ethernet cable and you are done!
					</span>
					<span>
						Our hardware probes are fully secure. <b>They don't allow any kind of access to your LAN</b>, they block all malicious and abusive endpoints,
						don't open any ports whatsoever and the firmware itself is fully open source.
					</span>
				</div>

				<div class="gp_probe_how-it-works_btns">
					<a target="_blank"
						rel="noopener noreferrer"
						href="https://github.com/jsdelivr/globalping-hwprobe"
						class="gp_probe_how-it-works_btns_learn-more gp_btn_black">
						Learn more
					</a>

					<a target="_blank"
						rel="noopener noreferrer"
						href="https://github.com/sponsors/jsdelivr"
						class="gp_probe_how-it-works_btns_sponsor gp_btn_green">
						<img width="20"
							height="20"
							src="{{@shared.assetsHost}}/img/globalping/github.small.svg">

						Become a GitHub Sponsor
					</a>
				</div>
			</div>
		</div>

		<div class="gp_sponsors">
			<div class="gp_sponsors_content">
				<div class="gp_sponsors_content_info">
					<span class="gp_sponsors_content_info_title">Globalping sponsors</span>

					<span class="gp_sponsors_content_info_descr">
						We thank everyone who decided to help our project by either running multiple globally distributed probes or donating to our cause.
					</span>
				</div>

				<div class="gp_sponsors_content_list">
					<div class="gp_sponsors_content_list_tier-one">
						<div class="gp_sponsors_content_list_tier-one_row">
							<a target="_blank" rel="noopener noreferrer" href="https://xtom.com">
								<img title="Sponsored by xTom"
									width="101"
									height="28"
									src="{{@shared.assetsHost}}/img/globalping/sponsors/xtom.svg">
							</a>
							<a target="_blank" rel="noopener noreferrer" href="https://looking.house">
								<img title="Sponsored by Looking.house"
									width="151"
									height="34"
									src="{{@shared.assetsHost}}/img/globalping/sponsors/looking-house.svg">
							</a>
						</div>

						<div class="gp_sponsors_content_list_tier-one_row">
							<a target="_blank" rel="noopener noreferrer" href="https://www.starrydns.com">
								<img title="Sponsored by StarryDNS"
									width="160"
									height="28"
									src="{{@shared.assetsHost}}/img/globalping/sponsors/starry.png">
							</a>
							<a target="_blank" rel="noopener noreferrer" href="https://www.ip2location.io/">
								<img title="Sponsored by IP2Location"
									width="169"
									height="28"
									src="{{@shared.assetsHost}}/img/globalping/sponsors/ip2location.svg">
							</a>
						</div>

						<div class="gp_sponsors_content_list_tier-one_row">
							<a target="_blank" rel="noopener noreferrer" href="https://www.exoscale.com">
								<img title="Sponsored by Exoscale"
									width="210"
									height="28"
									src="{{@shared.assetsHost}}/img/globalping/sponsors/exoscale.svg">
							</a>
							<a target="_blank" rel="noopener noreferrer" href="https://www.fdcservers.net">
								<img title="Sponsored by FDCServers"
									width="95"
									height="28"
									src="{{@shared.assetsHost}}/img/globalping/sponsors/fdc.svg">
							</a>
						</div>

						<div class="gp_sponsors_content_list_tier-one_row">
							<a target="_blank" rel="noopener noreferrer" href="https://ipinfo.io/">
								<img title="Sponsored by IPInfo"
									width="93"
									height="28"
									src="{{@shared.assetsHost}}/img/globalping/sponsors/ipinfo.svg">
							</a>
							<a target="_blank" rel="noopener noreferrer" href="https://www.edisglobal.com/">
								<img title="Sponsored by EDIS Global"
									width="91"
									height="28"
									src="{{@shared.assetsHost}}/img/globalping/sponsors/edis-global.svg">
							</a>
						</div>

						<div class="gp_sponsors_content_list_tier-one_row">
							<a target="_blank" rel="noopener noreferrer" href="https://www.misaka.io">
								<img title="Sponsored by Misaka Network, Inc."
									width="95"
									height="28"
									src="{{@shared.assetsHost}}/img/globalping/sponsors/misaka.svg">
							</a>
							<a target="_blank" rel="noopener noreferrer" href="https://zappiehost.com">
								<img title="Sponsored by Zappie Host"
									width="97"
									height="28"
									src="{{@shared.assetsHost}}/img/globalping/sponsors/zappiehost.png">
							</a>
						</div>

						<div class="gp_sponsors_content_list_tier-one_row">
							<a target="_blank" rel="noopener noreferrer" href="https://www.zenlayer.com/">
								<img title="Sponsored by Zenlayer"
									width="128"
									height="28"
									src="{{@shared.assetsHost}}/img/globalping/sponsors/zenlayer.svg">
							</a>
							<!-- swap images for better look depending on screenWidth -->
							{{#if screenWidth < 768}}
								<a target="_blank" rel="noopener noreferrer" href="https://www.dnsfilter.com/">
									<img title="Sponsored by DNSFilter"
										width="120"
										height="28"
										src="{{@shared.assetsHost}}/img/globalping/sponsors/dnsfilter.png">
								</a>
							{{else}}
								<a target="_blank" rel="noopener noreferrer" href="https://ipgeolocation.io/">
									<img title="Sponsored by IP Geolocation"
										width="97"
										height="56"
										src="{{@shared.assetsHost}}/img/globalping/sponsors/ipgeolocation.svg">
								</a>
							{{/if}}
						</div>

						<div class="gp_sponsors_content_list_tier-one_row">
							<a target="_blank" rel="noopener noreferrer" href="https://cloudlooking.glass/">
								<img title="Sponsored by Cloud Looking Glass"
									width="147"
									height="40"
									src="{{@shared.assetsHost}}/img/globalping/sponsors/cloud-looking-glass.png">
							</a>
							<!-- swap images for better look depending on screenWidth -->
							{{#if screenWidth < 768}}
								<a target="_blank" rel="noopener noreferrer" href="https://ipgeolocation.io/">
									<img title="Sponsored by IP Geolocation"
										width="97"
										height="56"
										src="{{@shared.assetsHost}}/img/globalping/sponsors/ipgeolocation.svg">
								</a>
							{{else}}
								<a target="_blank" rel="noopener noreferrer" href="https://www.dnsfilter.com/">
									<img title="Sponsored by DNSFilter"
										width="120"
										height="28"
										src="{{@shared.assetsHost}}/img/globalping/sponsors/dnsfilter.png">
								</a>
							{{/if}}
						</div>

						<div class="gp_sponsors_content_list_tier-one_row">
							<a target="_blank" rel="noopener noreferrer" href="https://onidel.com/">
								<img title="Sponsored by Onidel"
									width="130"
									height="32"
									src="{{@shared.assetsHost}}/img/globalping/sponsors/onidel.svg">
							</a>
							<a target="_blank" rel="noopener noreferrer" href="https://www.kuroit.com/">
								<img title="Sponsored by Kuroit"
									width="128"
									height="34"
									src="{{@shared.assetsHost}}/img/globalping/sponsors/kuroit.png">
							</a>
						</div>

						<div class="gp_sponsors_content_list_tier-one_row">
							<a target="_blank" rel="noopener noreferrer" href="https://exservers.net//">
								<img title="Sponsored by ExServers"
									width="156"
									height="28"
									src="{{@shared.assetsHost}}/img/globalping/sponsors/exservers.png">
							</a>
							<a target="_blank" rel="noopener noreferrer" href="https://netshop-isp.com.cy/">
								<img title="Sponsored by NetShop ISP"
									width="145"
									height="40"
									src="{{@shared.assetsHost}}/img/globalping/sponsors/netshop-logo-dark.svg">
							</a>
						</div>

						<div class="gp_sponsors_content_list_tier-one_row">
							<a target="_blank" rel="noopener noreferrer" href="https://www.host-stage.net/">
								<img title="Sponsored by HostStage"
									width="189"
									height="40"
									src="{{@shared.assetsHost}}/img/globalping/sponsors/host-stage.svg">
							</a>

							<a target="_blank" rel="noopener noreferrer" href="https://www.mvps.net/">
								<img title="Sponsored by MVPS"
									width="158"
									height="50"
									src="{{@shared.assetsHost}}/img/globalping/sponsors/mvps.svg">
							</a>
						</div>

						<div class="gp_sponsors_content_list_tier-one_row">
							<a target="_blank" rel="noopener noreferrer" href="https://www.iplocate.io/">
								<img title="Sponsored by IPLocate"
									width="164"
									height="27"
									src="{{@shared.assetsHost}}/img/globalping/sponsors/iplocate.svg">
							</a>
						</div>

						<!-- <div class="gp_sponsors_content_list_tier-two">
							<div class="gp_sponsors_content_list_tier-two_row">
								<div class="gp_person-sponsor">Robert  Kowalski</div>

								<img width="57"
									height="19"
									src="{{@shared.assetsHost}}/img/globalping/sponsors/dell.svg">

								<div class="gp_person-sponsor">Magdalene Tabhita</div>
							</div>
						</div> -->
					</div>
				</div>

				<a href="mailto:d@jsdelivr.com" class="gp_sponsors_content_btn gp_btn_green">
					Get in Contact
				</a>

				<img class="gp_sponsors_content_img"
					width="289"
					height="288"
					src="{{@shared.assetsHost}}/img/globalping/polygons_4.svg">
			</div>
		</div>
	</div>

	<c-gp-footer></c-gp-footer>
</r-page>

<script>
	const _ = require('../../../assets/js/_.js');
	const ipRegex = require('../../../assets/js/utils/ip-regex');
	const listeners = require('../../../assets/js/utils/listeners');
	const clipboard = require('../../../assets/js/decorators/clipboard');
	const http = require('../../../assets/js/utils/http');
	const has = require('../../../assets/js/utils/has');
	const CLIENT_DEFAULT_PING_OPTS = {
		protocol: 'ICMP',
	};
	const API_DEFAULT_PING_OPTS = {
		protocol: 'ICMP',
	};
	const CLIENT_DEFAULT_TRACEROUTE_OPTS = {
		protocol: 'ICMP',
	};
	const API_DEFAULT_TRACEROUTE_OPTS = {
		protocol: 'ICMP',
	};
	const CLIENT_DEFAULT_DNS_OPTS = {
		protocol: 'UDP',
		query: {
			type: 'A',
		},
		trace: false,
	};
	const API_DEFAULT_DNS_OPTS = {
		protocol: 'UDP',
		query: {
			type: 'A',
		},
		trace: false,
	};
	const CLIENT_DEFAULT_MTR_OPTS = {
		protocol: 'ICMP',
	};
	const API_DEFAULT_MTR_OPTS = {
		protocol: 'ICMP',
	};
	const CLIENT_DEFAULT_HTTP_OPTS = {
		protocol: 'HTTPS',
		request: {
			method: 'GET',
		},
	};
	const API_DEFAULT_HTTP_OPTS = {
		protocol: 'HTTPS',
		request: {
			method: 'HEAD',
		},
	};
	const DEFAULT_PACKETS_AMOUNT = 3;
	const DEFAULT_LIMIT = 1;
	const DOCKER_CMD_CONTENT = 'docker run -d --log-driver local --network host --restart=always --name globalping-probe globalping/globalping-probe';
	const DOCKER_CMD_CONTENT_FULL = [
		{
			cmd: 'docker run -d \\',
			comment: ' # Make sure the container runs on boot',
		},
		{
			cmd: '--log-driver local \\',
			comment: ' # Use the modern logging driver to ensure old logs are deleted',
		},
		{
			cmd: '--network host \\',
			comment: ' # Bypass overlay and mesh networking to ensure they dont impact latency tests',
		},
		{
			cmd: '--restart=always \\',
			comment: ' # Restart the container in case it crashes',
		},
		{
			cmd: '--name globalping-probe globalping/globalping-probe',
			comment: '',
		},
	];
	const PODMAN_CMD_CONTENT = 'sudo podman run -d --cap-add=NET_RAW --network host --restart=always --name globalping-probe globalping/globalping-probe';
	const PODMAN_CMD_CONTENT_FULL = [
		{
			cmd: 'sudo \\',
			comment: ' # Allows the --cap-add=NET_RAW option to work properly',
		},
		{
			cmd: 'podman run -d \\',
			comment: ' # The container will NOT start on boot. You need to create a systemd service first.',
		},
		{
			cmd: '--cap-add=NET_RAW \\',
			comment: ' # Network permissions to run ping',
		},
		{
			cmd: '--network host \\',
			comment: '# Bypass overlay and mesh networking to ensure they dont impact latency tests',
		},
		{
			cmd: '--restart=always \\',
			comment: ' # Restart the container in case it crashes',
		},
		{
			cmd: '--name globalping-probe globalping/globalping-probe',
			comment: '',
		},
	];
	const INITIAL_MAIN_OPTS_VALUES = {
		type: 'ping',
		target: '',
		location: 'World',
		limit: '10',
	};
	const MAP_MIN_ZOOM = 2;
	const MAP_MAX_ZOOM = 22;
	const MAP_ZOOM_REG = 3.74;
	const MAP_CENTER_REG = { lat: 48, lng: 16 };
	const MAP_ZOOM_ALT = 2.14;
	const MAP_CENTER_ALT = { lat: 30, lng: 18 };
	const DEFAULT_MARKER_COLOR = '#C0C0C0';
	const PROBE_NO_TIMING_VALUE = _.getProbeTimeOutValue();
	const PROBE_STATUS_FAILED = _.getProbeStatusFailedValue();
	const PROBE_STATUS_OFFLINE = _.getProbeStatusOfflineValue();
	const PROBE_OFFLINE_TEXT = 'Probe offline';
	const RAW_OUTPUT_LINES_BATCH_LIMIT = 40;
	const DEFAULT_TARGET_VALUE = 'cdn.jsdelivr.net';
	const INFINITE_MEASUREMENT_PACKETS = 16;
	const INFINITE_MEASUREMENT_LIMIT = 5;
	const RATE_LIMIT_HEADERS = [
		'x-ratelimit-limit',
		'x-ratelimit-consumed',
		'x-ratelimit-remaining',
		'x-ratelimit-reset',
		'x-credits-consumed',
		'x-credits-remaining',
		'x-request-cost',
	];
	const PORT_SUPPORTED_BY_TYPE = {
		ping: [ 'TCP' ],
		traceroute: [ 'TCP' ],
		mtr: [ 'TCP', 'UDP' ],
	};
	const getMarkerSize = (probeCount, zoom) => {
		let size = {
			svgWidth: 16,
			svgHeight: 16,
			circleRadius: 4.5,
			strokeWidth: 1.5,
		};

		if (probeCount > 1) {
			let scalingFactor = probeCount.toString().length;
			size.svgWidth += 4 * scalingFactor + 4;
			size.svgHeight += 4 * scalingFactor + 4;
			size.circleRadius += 2 * scalingFactor + 1.5;
			size.strokeWidth += .5;
		}

		if (zoom >= 5) {
			size.svgWidth *= 1.1;
			size.svgHeight *= 1.1;
		}

		if (zoom >= 10) {
			size.svgWidth *= 1.1;
			size.svgHeight *= 1.1;
		}

		return size;
	};
	const originalMapMarkersPos = new Map();
	const DEFAULT_MARKER_DIMENSIONS = 24;

	let map;
	let infoWindows = [];
	let mapMarkers = [];
	let probesMarkers = [];
	let probesInfoWindows = [];
	let mapProbesClusters = [];

	component.exports = {
		decorators: {
			clipboard,
		},
		data () {
			return {
				_,
				map: null,
				display: null,
				rawProbes: '',
				PROBE_NO_TIMING_VALUE,
				PROBE_STATUS_FAILED,
				PROBE_STATUS_OFFLINE,
				DEFAULT_TARGET_VALUE,
				INFINITE_MEASUREMENT_LIMIT,
				INITIAL_MAIN_OPTS_VALUES,
				testTypesList: [ 'ping', 'traceroute', 'DNS', 'MTR', 'HTTP' ],
				mainOptions: {
					...INITIAL_MAIN_OPTS_VALUES,
				},
				showMap: true,
				originalShowMap: true,
				transitionMap: true,
				infiniteSwitchEnabled: false,
				showMeasurementOpts: false,
				dnsTypesList: [ 'A', 'AAAA', 'ANY', 'CNAME', 'DNSKEY', 'DS', 'MX', 'NS', 'NSEC', 'PTR', 'RRSIG', 'SOA', 'TXT', 'SRV', 'SVCB' ],
				netDockerCmdText: DOCKER_CMD_CONTENT,
				netDockerCmdTextFull: DOCKER_CMD_CONTENT_FULL,
				netPodmanCmdText: PODMAN_CMD_CONTENT,
				netPodmanCmdTextFull: PODMAN_CMD_CONTENT_FULL,
				totalProbes: 0,
				totalCities: 0,
				totalCountries: 0,
				pingOpts: JSON.parse(JSON.stringify(CLIENT_DEFAULT_PING_OPTS)), // deep copy is needed here, as default values for other options are deep-copied elsewhere
				tracerouteOpts: CLIENT_DEFAULT_TRACEROUTE_OPTS,
				dnsOpts: CLIENT_DEFAULT_DNS_OPTS,
				mtrOpts: CLIENT_DEFAULT_MTR_OPTS,
				httpOpts: CLIENT_DEFAULT_HTTP_OPTS,
				inputErrors: {},
				testResults: null,
				testInProgress: false,
				testReqInterval: null,
				notAppliedOpts: {},
				defaultPacketsAmount: DEFAULT_PACKETS_AMOUNT,
				defaultLimit: DEFAULT_LIMIT,
				probesMinTiming: 5,
				joinNetSwitchValue: 'docker',
				showCommandsBlock: false,
				scrolledToResIdx: null,
				modifiedMeasOptsCnt: 0,
				appliedMeasOpts: {},
				shareResHeaderData: null,
				runTestBtnText: 'Run Test',
				testReqParams: null,
				probesResponse: null,
				shareResFlow: false,
				activeTargetIdx: 0,
				rawOutputMode: true,
				measurementsMetadata: null,
				targetsArr: [],
				qsMeasurementIdsArr: [],
				showCreditsError: false,
				infiniteMeasIds: [],
				isInfiniteMeasStopped: false,
				isInfiniteModeRes: false,
				prevProbesMeasId: null,
				preparedTestResults: [],
				ddHandlerSet: false,
				showCreditsData: false,
				rateCreditsData: null,
				measurementErrMsg: null,
				probesMaxTiming: 200,
			};
		},
		computed: {
			ogTitle () {
				return this.get('_measurementOgTitle');
			},
			ogDescription () {
				return this.get('_measurementOgDescription');
			},
			disablePort () {
				let type = this.get('mainOptions.type').toLowerCase();
				let opts = this.get(`${type}Opts`);

				let supportedProtocols = PORT_SUPPORTED_BY_TYPE[type];

				if (!supportedProtocols) {
					return false;
				}

				return !supportedProtocols.includes(opts?.protocol ?? '');
			},
			location: {
				get () {
					// This is a one-way setter.
					return this.get('_location');
				},
				set (value) {
					this.set('_location', value);
					this.set('mainOptions.location', value.replace(/%/g, '+'));
				},
			},
		},
		onrender () {
			if (!Ractive.isServer) {
				this.set('@shared.googleMapsLoaded', true);

				if (app.loaded) {
					this.initMap();
				}

				listeners.screenWidthListener(this);
			}
		},
		oninit () {
			if (!Ractive.isServer) {
				this.on('c-header.main-logo-click', () => {
					this.set('measurement', '');
					return false;
				});

				// check if ids are present in query string
				// if so - it is a share-results-flow
				let measurement = this.get('measurement');
				let qsMeasurementIdsArr = [];
				let isInfiniteMeas = false;
				let isMultiEpMeas = false;

				// A separator for IDs for regular link is a comma, for infinite one - plus sign
				if (measurement && measurement.includes(',')) {
					qsMeasurementIdsArr = measurement.split(',');
					isMultiEpMeas = true;
				} else if (measurement && measurement.includes('.')) {
					qsMeasurementIdsArr = measurement.split('.');
					isInfiniteMeas = true;

					this.set('infiniteSwitchEnabled', true);
					this.set('isInfiniteModeRes', true);
					this.set('rawOutputMode', false);
				} else if (measurement) {
					qsMeasurementIdsArr = [ measurement ];
				}

				if (qsMeasurementIdsArr.length) {
					this.set('qsMeasurementIdsArr', qsMeasurementIdsArr);
					this.set('shareResFlow', true);

					this.getMultipleTestMeasurementById(qsMeasurementIdsArr, isInfiniteMeas);
				}

				// read the map and display URL params and apply them
				let map = this.get('map');
				let display = this.get('display');

				if (map === 'hidden') {
					this.set('showMap', false);
				}

				let nonDefaultDisplayValue = isMultiEpMeas || isInfiniteMeas ? 'raw' : 'table';

				if (display === nonDefaultDisplayValue) {
					// if valid, set the non-default value in params
					this.set('rawOutputMode', display === 'raw');
				} else {
					// otherwise set the appropriate default value
					// for multi-endpoint tests, this always sets the display to table
					// if the test is not ping, it is changed back to raw in an observer
					this.set('rawOutputMode', nonDefaultDisplayValue !== 'raw');
				}

				// get probes from sessionStorage or fetch them and handle
				this.getProbesData();

				// disable rawOutputMode whenever test type isn't ping
				this.observe('testReqParams.type', (testType) => {
					if (testType && testType !== 'ping') {
						this.set('rawOutputMode', true);
					}
				});

				// persist non-default display value in the URL
				this.observe('rawOutputMode testReqParams.type', () => {
					let testType = this.get('testReqParams.type');

					if (!testType) {
						return;
					}

					let rawOutputMode = this.get('rawOutputMode');
					let isInfiniteMeas = this.get('isInfiniteModeRes');
					let isMultiEpMeas = this.get('measurement')?.split(',')?.length >= 2;

					if (testType === 'ping' && (isInfiniteMeas || isMultiEpMeas)) {
						app.router.replaceQueryParam('display', rawOutputMode ? 'raw' : null, this);
					} else {
						app.router.replaceQueryParam('display', rawOutputMode ? null : 'table', this);
					}
				});

				// persist non-default map value in the URL
				this.observe('showMap', (showMap) => {
					app.router.replaceQueryParam('map', showMap ? null : 'hidden', this);
				});

				// handle test type switch
				this.observe('mainOptions.type', (type) => {
					// if qsMeasurementIdsArr - share-results-flow, so type would be set, we should ignore this case
					if (this.get('qsMeasurementIdsArr').length) {
						return;
					}

					this.set('showMeasurementOpts', false);
					this.set('inputErrors', {});
					this.set(`${type.toLowerCase()}Opts`, this.getDefaultClientMeasOptsByTestName(type));
					this.set('appliedMeasOpts', {});
					this.set('notAppliedOpts', {});
					this.set('measurementErrMsg', null);
					this.set('modifiedMeasOptsCnt', 0);
					this.set('infiniteSwitchEnabled', false);
				}, { init: false });

				// when infinite switch is enabled set limit to INFINITE_MEASUREMENT_LIMIT if limit is bigger than INFINITE_MEASUREMENT_LIMIT
				this.observe('infiniteSwitchEnabled', (infiniteSwitchEnabled) => {
					let currentLimit = this.get('mainOptions.limit');

					if (infiniteSwitchEnabled && currentLimit > INFINITE_MEASUREMENT_LIMIT) {
						this.set('mainOptions.limit', INFINITE_MEASUREMENT_LIMIT);
					} else if (infiniteSwitchEnabled === false && currentLimit > INFINITE_MEASUREMENT_LIMIT) {
						this.set('mainOptions.limit', INITIAL_MAIN_OPTS_VALUES.limit);
					}
				});

				// handle limit changing when infinite switch is enabled - disable input if it is bigger than INFINITE_MEASUREMENT_LIMIT
				this.observe('mainOptions.limit', (currentLimit) => {
					let infiniteSwitchEnabled = this.get('infiniteSwitchEnabled');

					if (infiniteSwitchEnabled && currentLimit >= INFINITE_MEASUREMENT_LIMIT) {
						this.set('mainOptions.limit', INFINITE_MEASUREMENT_LIMIT);
					}
				});

				// handle join-network switch and commands content
				this.observe('joinNetSwitchValue', (joinNetSwitchValue) => {
					let netCmdText;
					let netCmdTextFull;

					switch (joinNetSwitchValue) {
						case 'podman':
							netCmdText = this.get('netPodmanCmdText');
							netCmdTextFull = this.get('netPodmanCmdTextFull');
							break;
						case 'docker':
						default:
							netCmdText = this.get('netDockerCmdText');
							netCmdTextFull = this.get('netDockerCmdTextFull');
					}

					this.set('netCmdText', netCmdText);
					this.set('netCmdTextFull', netCmdTextFull);

					let clipboardValue = netCmdTextFull.map(part => part.cmd).join('\n');

					this.set('netCmdTextFullClipboard', clipboardValue);

					if (this.get('showCommandsBlock')) {
						this.set('showCommandsBlock', false);
					}
				});

				// handle show-hide full join-network command
				this.observe('showCommandsBlock', (showCommandsBlock) => {
					if (showCommandsBlock) {
						this.expandCmdBlock();
					} else {
						this.collapseCmdBlock();
					}
				}, { init: false, defer: true });

				// zoom to results once we get the first response
				this.observe('realTimeTestResResponse', (responses, prevResponses) => {
					if (!prevResponses && responses && responses.every(r => r.results.length) && responses[0]) {
						this.zoomToResults(responses[0].locations);
					}
				}, { init: false });

				// handle test results in real time
				this.observe('realTimeTestResResponse', (realTimeTestResResponse) => {
					if (!realTimeTestResResponse) { return; }

					// clear interval for the related request when it's finished, collect reponses statuses
					let respStatuses = realTimeTestResResponse.reduce((statusObj, r, rIdx) => {
						if (r.status === 'finished') {
							clearInterval(this.get('testReqInterval')[rIdx]);

							return { ...statusObj, [rIdx]: true };
						}

						return { ...statusObj, [rIdx]: false };
					}, {});

					// check respStatuses and handle the case when all requests are finished unless it is an infinite flow
					let infiniteSwitchEnabled = this.get('infiniteSwitchEnabled');
					let targetsArrLength = this.get('targetsArr').length;

					if (
						!(targetsArrLength === 1 && infiniteSwitchEnabled)
						&& Object.values(respStatuses).length === targetsArrLength
						&& Object.values(respStatuses).every(s => s === true)
					) {
						this.set('testInProgress', false);

						// if it is a share-results-flow - scroll mapBlock into the view
						if (this.get('shareResFlow')) {
							this.scrollMapIntoView();
						}
					}

					if (realTimeTestResResponse && realTimeTestResResponse.length) {
						realTimeTestResResponse.forEach((rtTestRes, rtTestResIdx) => {
							let prevTestResults = this.get(`testResults[${rtTestResIdx}]`);
							let testResults = rtTestRes.results.map((res, resIdx) => ({
								id: rtTestRes.id,
								clientSideId: resIdx,
								target: rtTestRes.target,
								type: rtTestRes.type,
								clientSideStartedAt: prevTestResults ? prevTestResults[resIdx].clientSideStartedAt : rtTestRes.clientSideStartedAt,
								clientSideUpdatedAt: rtTestRes.clientSideUpdatedAt,
								serverTime: new Date(rtTestRes.updatedAt).getTime() - new Date(rtTestRes.createdAt).getTime(),
								status: rtTestRes.status,
								...res,
							}));

							if (JSON.stringify(testResults) !== JSON.stringify(prevTestResults)) {
								this.set(`testResults[${rtTestResIdx}]`, testResults);
							}
						});
					}
				}, { init: false });

				// prepare data for Markers of the map, timings for the map scale
				this.observe('testResults', (testResults) => {
					if (!testResults) { return; }

					let dnsOpts = this.get('dnsOpts');
					let testType = this.get('mainOptions.type');
					let targetsCnt = this.get('targetsArr').length;
					let infiniteSwitchEnabled = this.get('infiniteSwitchEnabled');

					// combine results
					// if it is a regular measurement then each array element is corresponds to each target, these arrays elements contain data per probe for this target
					// if Infinite measurement - each array element is a new request's response, each el inside such array is a data for probe
					let parsedMeasData = testResults.reduce((mData, tRes, tResIdx) => {
						if (!tRes || !tRes.length) {
							return mData;
						}

						let mappedRes = tRes.map((res, resIdx) => {
							let calcTiming = null;
							let data = {
								id: res.id,
								clientSideId: res.clientSideId,
								network: res.probe.network,
								city: res.probe.city,
								country: res.probe.country,
								lat: res.probe.latitude,
								lng: res.probe.longitude,
								targets: [ res.target ],
							};

							if (infiniteSwitchEnabled) {
								let { packetsRtt } = _.parseGpRawOutputForTimings(res.result.rawOutput);
								let prevPacketsRtt = tResIdx - 1 >= 0 ? mData[tResIdx - 1][resIdx].packetsRtt : [];
								let allCurrPacketsRtt = [ ...prevPacketsRtt, ...packetsRtt ];
								let numericPacketsRtt = allCurrPacketsRtt.filter(v => typeof v === 'number');

								data = {
									...data,
									packetsRtt: allCurrPacketsRtt,
								};

								if (res.result.status === PROBE_STATUS_FAILED) {
									calcTiming = {
										value: PROBE_STATUS_FAILED,
									};
								} else if (res.result.status === PROBE_STATUS_OFFLINE) {
									calcTiming = {
										value: PROBE_STATUS_OFFLINE,
									};
								} else if (numericPacketsRtt.length) {
									calcTiming = {
										value: Math.round(numericPacketsRtt.reduce((sum, rtt) => sum += rtt, 0) / numericPacketsRtt.length),
										units: ' ms',
									};
								} else if (packetsRtt.length && packetsRtt.every(v => v === _.getProbeTimeOutValue())) {
									calcTiming = {
										value: _.getProbeTimeOutValue(),
									};
								} else {
									calcTiming = {
										value: tResIdx - 1 >= 0 ? mData[tResIdx - 1][resIdx].timings[0] : null,
									};
								}
							} else if (res.result.status !== 'in-progress') {
								calcTiming = _.calcGpTestResTiming(testType, res, dnsOpts.trace);
							}

							let resTiming = !calcTiming ? null : typeof calcTiming.value === 'number' ? `${Math.round(calcTiming.value)}${calcTiming.units}` : calcTiming.value;

							return {
								...data,
								timings: [ resTiming ],
							};
						});

						return { ...mData, [tResIdx]: mappedRes };
					}, {});

					// markersData for the first target, regular flow
					let markersData = parsedMeasData[0];

					// in case of infinite flow, get the latest data
					if (infiniteSwitchEnabled) {
						let lastIdx = Object.keys(parsedMeasData).length - 1;

						markersData = parsedMeasData[lastIdx];
					}

					// if there are another targets then we should add its data to markersData respectively
					if (targetsCnt > 1) {
						for (let cnt = 1; cnt < targetsCnt; cnt++) {
							if (!parsedMeasData[cnt]) { return; }

							markersData = markersData.map((mD) => {
								let secReqMD = parsedMeasData[cnt].find(i => i.clientSideId === mD.clientSideId);

								return {
									...mD,
									timings: [ ...mD.timings, ...secReqMD.timings ],
									targets: [ ...mD.targets, ...secReqMD.targets ],
								};
							});
						}
					}

					this.set('markersData', markersData);
				}, { init: false });

				// check the statuses of probes in the measurement and stop measurement if all of them are failed
				this.observe('testResults', (testResults) => {
					for (let i in testResults) {
						if (testResults[i].every(r => r.result.status === PROBE_STATUS_FAILED)) {
							this.stopInfiniteTest();

							return;
						}
					}
				});

				// prepare results for gp-results-raw-output and gp-results-table-output, regular or infinite flow
				this.observe('testResults', (testResults) => {
					if (!testResults) { return; }

					let testType = this.get('testReqParams.type');
					let isInfiniteModeRes = this.get('isInfiniteModeRes');
					let preparedTestResults;

					if (testType === 'ping' && isInfiniteModeRes) {
						preparedTestResults = this.prepareInfiniteResults(testResults);
					} else {
						preparedTestResults = this.prepareRegularResults(testResults);
					}

					this.set('preparedTestResults', preparedTestResults);
				});

				// set initial screenWidth value
				this.observe('screenWidth', (screenWidth) => {
					if (!screenWidth) {
						this.set('screenWidth', window.innerWidth);
					}
				});

				// handle tooltips positions depending on the screen size
				this.observe('screenWidth', (screenWidth) => {
					let ttPositions = {};

					if (screenWidth >= 1272) {
						ttPositions.targetTtPos = 'top';
						ttPositions.locationTtPos = 'top';
						ttPositions.limitTtPos = 'top';
					} else if (screenWidth >= 768) {
						ttPositions.targetTtPos = 'top';
						ttPositions.locationTtPos = 'right';
						ttPositions.limitTtPos = 'top';
					} else {
						ttPositions.targetTtPos = 'right';
						ttPositions.locationTtPos = 'right';
						ttPositions.limitTtPos = 'right';
					}

					this.set('ttPositions', ttPositions);
				});

				// disable Infinite switch if there is more than one target
				this.observe('mainOptions.target', (target) => {
					if (target.split(',').length > 1) {
						let infiniteSwitchEnabled = this.get('infiniteSwitchEnabled');

						if (infiniteSwitchEnabled) {
							this.set('notAppliedOpts.packets', '');
							this.set('infiniteSwitchEnabled', false);
							this.applyOptions();
						}
					}
				});

				// add navigation functionality once the Run Test button with dropdown appeared
				this.observe('testInProgress', (testInProgress) => {
					let prevProbesMeasId = this.get('prevProbesMeasId');

					if (prevProbesMeasId && !testInProgress) {
						this.handleDropDownRunTestBtnNav();
					}
				});

				this.observe('showMap', (newValue) => {
					if (!newValue && this.get('originalShowMap')) {
						this.set('transitionMap', false);
					} else {
						// using a deferred observer somehow isn't sufficient here
						setTimeout(() => {
							this.set('transitionMap', true);
						}, 100);
					}
				});
			}
		},
		oncomplete () {
			if (!Ractive.isServer) {
				// run the test if user is pressed Enter inside of any of main options inputs
				let targetInput = this.find('#targetInput');
				let limitInput = this.find('#limitInput');

				let handleEnterBtn = (event) => {
					if (event.key === 'Enter') {
						event.preventDefault();
						this.resetMapAndRunTest();
					}
				};

				targetInput.addEventListener('keypress', handleEnterBtn);
				limitInput.addEventListener('keypress', handleEnterBtn);
			}
		},
		proceedToTest (prevProbesMeasId) {
			let { type, target, location, limit, ipVersion } = this.get('mainOptions');
			let appliedMeasOpts = this.get('appliedMeasOpts');
			let measurementOpts = _.deepExtend({}, appliedMeasOpts.initPresetOpts, appliedMeasOpts.notPresetOpts);
			let targetsArr = target.split(',').map(target => target.trim());
			let infiniteSwitchEnabled = this.get('infiniteSwitchEnabled');

			// create parameters for the measurement request
			let reqParams = {
				type,
				// to get test results in real time
				inProgressUpdates: true,
			};

			// ipVersion should be passed only if there is 1 target and it is a domain name and test type is not a DNS
			if (ipVersion && type.toLowerCase() !== 'dns') {
				measurementOpts = {
					...measurementOpts,
					ipVersion,
				};
			}

			reqParams.limit = limit || DEFAULT_LIMIT;

			if (location) {
				reqParams.locations = location.split(',').map(loc => ({ magic: loc }));
			} else {
				this.set('mainOptions.location', INITIAL_MAIN_OPTS_VALUES.location);

				reqParams.locations = [{ magic: INITIAL_MAIN_OPTS_VALUES.location }];
			}

			// since packets field default value is present only for Ping and MTR type
			if (type.toLowerCase() === 'ping' || type.toLowerCase() === 'mtr') {
				reqParams.measurementOptions = {
					// set default values in case if user did not set them manually
					packets: DEFAULT_PACKETS_AMOUNT,
				};
			} else {
				delete measurementOpts.packets;

				if (type.toLowerCase() === 'http') {
					reqParams.measurementOptions = {
						request: {
							method: measurementOpts?.request?.method || CLIENT_DEFAULT_HTTP_OPTS.request.method,
						},
					};
				}
			}

			if (Object.keys(measurementOpts).length) {
				reqParams.measurementOptions = {
					...reqParams.measurementOptions || {},
					...measurementOpts,
				};
			}

			// clear all data from the previous test, close additional options menu, show spinner, set up Map's data etc.
			this.set('testResults', null);
			this.set('markersData', null);
			this.set('probesResponse', null);
			this.set('showMeasurementOpts', false);
			this.set('testInProgress', true);
			this.set('measurementErrMsg', null);
			this.set('testReqParams', null);
			this.set('shareResFlow', false);
			this.set('shareResHeaderData', null);
			this.set('realTimeTestResResponse', null);
			this.set('activeTargetIdx', 0);
			this.set('measurementsMetadata', null);
			this.set('showCreditsError', false);
			this.set('targetsArr', targetsArr);
			this.set('infiniteMeasIds', []);
			this.set('isInfiniteMeasStopped', false);
			this.set('showCreditsData', true);
			this.set('prevProbesMeasId', null);
			this.set('preparedTestResults', []);
			this.set('rateCreditsData', null);
			this.set('probesMaxTiming', type.toLowerCase() === 'http' ? 1000 : 200);
			this.set('_measurementOgTitle', null);
			this.set('_measurementOgDescription', null);

			// if it is infinite/multi-endpoint measurement then we should show TableOutput by default
			// otherwise leave prev value set by user
			if (type === 'ping' && (infiniteSwitchEnabled || targetsArr.length >= 2)) {
				this.set('rawOutputMode', false);
			}

			// is designed to prevent the way the test results are displayed from changing when the user toggles the infinite switch
			this.set('isInfiniteModeRes', infiniteSwitchEnabled);

			// re-use probes case
			if (prevProbesMeasId) {
				reqParams = {
					...reqParams,
					locations: prevProbesMeasId,
				};
			}

			// run Infinite type of the measurement
			if (type === 'ping' && targetsArr.length === 1 && infiniteSwitchEnabled) {
				this.postInfiniteGlobalpingMeasurement({ reqParams, target: targetsArr[0] });

				return;
			}

			// common type of the measurement
			http.postGlobalpingMeasurement({ ...reqParams, target: targetsArr[0] }, RATE_LIMIT_HEADERS).then((res) => {
				// set measurement ID for re-use probes case
				this.set('prevProbesMeasId', res.response.id);

				// Update the URL.
				this.set('measurement', res.response.id);

				// set response headers for gp-credits/gp-credits-message
				this.set('rateCreditsData', { ...res.responseHeaders });

				if (targetsArr[1]) {
					let secReqParams;

					// prepare params depending whether there is prevProbesMeasId or not
					if (prevProbesMeasId) {
						secReqParams = { locations: res.response.id, ...reqParams, target: targetsArr[1] };
					} else {
						secReqParams = { ...reqParams, locations: res.response.id, target: targetsArr[1] };
					}

					http.postGlobalpingMeasurement(secReqParams, RATE_LIMIT_HEADERS).then((res1) => {
						let combinedHeaders = { ...res1.responseHeaders };

						[
							'x-ratelimit-consumed',
							'x-credits-consumed',
							'x-request-cost',
						].forEach((header) => {
							combinedHeaders[header] = (Number(res.responseHeaders[header]) || 0) + (Number(res1.responseHeaders[header]) || 0);
						});

						// set response headers for gp-credits/gp-credits-message
						this.set('rateCreditsData', combinedHeaders);
						this.getTestMeasurementById({ measurementId: res.response.id });
						this.getTestMeasurementById({ measurementId: res1.response.id, resNumber: 1 });
						this.set('showMap', this.get('originalShowMap'));

						// Update the URL without creating a new history entry.
						app.router.replaceQueryParam('measurement', `${this.get('measurement')},${res1.response.id}`);
					}).catch((err) => {
						this.handlePostGPMeasError(err);
					});
				} else {
					this.getTestMeasurementById({ measurementId: res.response.id });
					this.set('showMap', this.get('originalShowMap'));
				}
			}).catch((err) => {
				this.handlePostGPMeasError(err);
			});
		},
		applyOptions () {
			// Clear the port input in the case the selected protocol does not support it
			if (this.get('disablePort')) {
				this.set('notAppliedOpts.port', '');
			}

			// filter opts from empty values
			let filterOptsFromEmptyOne = opts => Object.keys(opts).reduce((res, key) => {
				if (typeof opts[key] === 'object') {
					res[key] = Object.keys(opts[key]).reduce((secRes, secKey) => {
						if (opts[key][secKey] !== '') {
							secRes[secKey] = opts[key][secKey];
						}

						return secRes;
					}, {});
				} else if (opts[key] !== '') {
					res[key] = opts[key];
				}

				return res;
			}, {});

			let { type } = this.get('mainOptions');
			let currOptsName = `${type.toLowerCase()}Opts`;
			let initPresetOpts = filterOptsFromEmptyOne(this.get(currOptsName));
			let notPresetOpts = filterOptsFromEmptyOne(this.get('notAppliedOpts'));
			let opts = {
				initPresetOpts,
				notPresetOpts,
			};

			this.set('appliedMeasOpts', opts);

			this.countModifiedMeasurementOpts(type, initPresetOpts, notPresetOpts);

			this.set('showMeasurementOpts', false);
		},
		initMap () {
			let mq = window.matchMedia('(min-width: 768px)');

			map = new google.maps.Map(this.find('#gp-map'), {
				zoom: MAP_ZOOM_REG,
				center: MAP_CENTER_REG,
				mapTypeId: 'roadmap',
				draggableCursor: 'default',
				mapTypeControl: false,
				streetViewControl: false,
				fullscreenControl: false,
				minZoom: MAP_MIN_ZOOM,
				maxZoom: MAP_MAX_ZOOM,
				mapId: 'ce04bbf9d49b6f34',
			});

			if (mq.matches) {
				map.setCenter(MAP_CENTER_ALT);
				map.setZoom(MAP_ZOOM_ALT);
			}

			// handle map changes on zoom
			map.addListener('zoom_changed', () => {
				// close all IWs on zoom
				infoWindows.forEach(iw => iw.close());
				probesInfoWindows.forEach(piw => piw.close());

				this.despiderifyMapMarkers(mapMarkers);

				// scale cluster's markers size on zoom
				probesMarkers.forEach((m) => {
					let { svgWidth, svgHeight } = getMarkerSize(Number(m.content.getAttribute('data-probe-count')), map.zoom);

					m.content.style.width = `${svgWidth}px`;
					m.content.style.height = `${svgHeight}px`;
				});
			});

			// draw probes Clusers or clear the map from them
			this.observe('probesResponse', (probesResponse) => {
				// when we run a new test probesResponse will be cleared ergo we should clear the map from the probesClusters
				if (probesResponse === null) {
					this.clearProbesClusters();
				// display probesCLusters on the map only when we have probesData and not in share-results-flow
				} else if (probesResponse && !this.get('shareResFlow')) {
					this.updateClusters(probesResponse);
				}
			});

			// check whether we should clear the Map from the markers or update them
			this.observe('markersData', (markersData, prevMarkersData) => {
				if (markersData === null) {
					this.clearTestResponseMarkers();
				} else if (JSON.stringify(markersData) !== JSON.stringify(prevMarkersData)) {
					// update Markers on the map (replace or add new) if Markers data is different
					this.updateMarkers(markersData, prevMarkersData);
				}
			}, { init: false });
		},
		updateMarkers (markersData, prevMarkersData) {
			markersData.forEach((markerData) => {
				let markerIdToReplace = null;
				let currentMarkerIdx = markerData.clientSideId;

				// check if the new Marker is the old one but with a timing value
				// and get Marker index to replace it later on the Map
				// get index for every Marker we draw or redraw on the map to provide proper work of InfoWindows, Results and Actions etc.
				if (prevMarkersData) {
					// stop once we found the match to get proper currentMarkerIdx
					prevMarkersData.every((pmd) => {
						if (
							pmd.clientSideId === markerData.clientSideId
							&& markerData.timings !== null
							&& markerData.timings.every(t => t)
						) {
							markerIdToReplace = pmd.clientSideId;
							currentMarkerIdx = pmd.clientSideId;

							return false;
						}

						return true;
					});
				}

				// create a new marker and add it to the map or update existing with new data
				if (markerIdToReplace !== null) {
					mapMarkers.forEach((mm, mmIdx) => {
						if (markerIdToReplace === mmIdx && JSON.stringify(markerData.timings) !== JSON.stringify(prevMarkersData[markerIdToReplace].timings)) {
							this.updateMapMarkerWithIW(mm, markerData, currentMarkerIdx);
						}
					});
				} else if (!mapMarkers[markerData.clientSideId]) {
					// collect markers added to the map
					this.createMapMarkerWithIW(markerData, currentMarkerIdx);
				}
			});

			// close IWs on click on Map
			google.maps.event.addListener(map, 'click', () => {
				infoWindows.forEach(iw => iw.close());

				this.despiderifyMapMarkers(mapMarkers);
			});
		},
		updateClusters (probes) {
			let preparedMarkers = Object.keys(probes).map((key) => {
				let [ lat, lng ] = key.split(', ');
				let marker = probesMarkers.find(pm => pm.position.lat === lat && pm.position.lng === lng);

				if (!marker) {
					marker = this.createMapClusterMarkerWithIW(key, probes[key]);
					probesMarkers.push(marker);
				}

				marker.map = map;

				return marker;
			});

			// eslint-disable-next-line no-undef
			let probeCluster = new markerClusterer.MarkerClusterer({
				markers: preparedMarkers,
				map,
				renderer: {
					render ({ markers, position }) {
						let totalCustomNumber = markers.reduce((sum, marker) => sum + (marker.markersCount || 0), 0);
						let clusterSvg = window.btoa(`<svg xmlns="http://www.w3.org/2000/svg" width="68" height="68" fill="none">
							<g clip-path="url(#a)">
							<path fill="url(#b)" d="M30 2.31a8 8 0 0 1 8 0l21.445 12.38a8 8 0 0 1 4 6.929V46.38a8 8 0 0 1-4 6.928L38 65.691a8 8 0 0 1-8 0L8.555 53.309a8 8 0 0 1-4-6.928V21.62a8 8 0 0 1 4-6.928z"/>
							<path stroke="#69E7C8" stroke-width="1.5" d="M30.375 4.959a7.25 7.25 0 0 1 7.25 0L57.338 16.34a7.25 7.25 0 0 1 3.625 6.279V45.38a7.25 7.25 0 0 1-3.625 6.279L37.625 63.04a7.25 7.25 0 0 1-7.25 0L10.662 51.66a7.25 7.25 0 0 1-3.625-6.279V22.62a7.25 7.25 0 0 1 3.625-6.279L30.375 4.96Z"/>
							</g>
							<text x="34" y="40" fill="#fff" font-family="Lexend, sans-serif" font-size="16px" font-weight="600" text-anchor="middle">
							${totalCustomNumber}
							</text>
							<defs>
							<linearGradient id="b" x1="34" x2="34" y1="0" y2="68" gradientUnits="userSpaceOnUse">
							<stop stop-color="#17D4A7"/>
							<stop offset="1" stop-color="#17D4A7"/>
							</linearGradient>
							<clipPath id="a">
							<path fill="#fff" d="M0 0h68v68H0z"/>
							</clipPath>
							</defs>
						</svg>`);
						let clusterDiv = document.createElement('div');
						let clusterImg = document.createElement('img');

						clusterDiv.style.position = 'relative';
						clusterDiv.style.width = '68px';
						clusterDiv.style.height = '68px';
						clusterDiv.style.background = 'transparent';
						clusterImg.src = `data:image/svg+xml;base64,${clusterSvg}`;
						clusterImg.width = '68';
						clusterImg.height = '68';
						clusterDiv.appendChild(clusterImg);

						return new google.maps.marker.AdvancedMarkerElement({
							position,
							content: clusterDiv,
						});
					},
				},
				// eslint-disable-next-line no-undef
				algorithm: new markerClusterer.SuperClusterAlgorithm({
					radius: 200,
				}),
			});

			mapProbesClusters.push(probeCluster);

			google.maps.event.addListener(map, 'click', () => {
				probesInfoWindows.forEach(piw => piw.close());
			});
		},
		clearTestResponseMarkers () {
			infoWindows.forEach(iw => iw.close());
			mapMarkers.forEach(mm => mm.setMap(null));
			infoWindows = [];
			mapMarkers = [];
		},
		clearProbesClusters () {
			probesInfoWindows.forEach(piw => piw.close());
			mapProbesClusters.forEach(pc => pc.setMap(null));
			probesMarkers = [];
			probesInfoWindows = [];
			mapProbesClusters = [];
		},
		collapseCmdBlock () {
			let element = document.querySelector('.gp_join-network_cmd-block_command');

			requestAnimationFrame(() => {
				element.style.height = `${element.scrollHeight}px`;

				requestAnimationFrame(() => {
					element.style.height = '56px';
				});
			});
		},
		expandCmdBlock () {
			let element = document.querySelector('.gp_join-network_cmd-block_command');

			requestAnimationFrame(() => {
				element.style.height = '56px';

				requestAnimationFrame(() => {
					element.style.height = `${element.scrollHeight}px`;
				});
			});
		},
		handleSeeResults (resIdx) {
			let el;

			if (this.get('rawOutputMode')) {
				el = this.find(`.c-gp-results-raw-output_list .c-gp-results-raw-output_list_item_top-wrapper:nth-child(${resIdx + 1})`);
			} else {
				el = this.find(`.c-gp-results-table-output .results-table_row.row-num-${resIdx}`);
			}

			// this prop will be passed to c-gp-results-raw-output in order for it to show the specific result element if it was hidden
			this.set('scrolledToResIdx', resIdx);

			el.scrollIntoView({ behavior: 'smooth' });
		},
		getTestMeasurementById ({
			measurementId,
			resNumber = '0',
			isShareResCase = false,
			isFirstShareReq = false,
			isLastShareReq = false,
			isInfiniteMeas = false,
			reqParams = {},
		}) {
			return new Promise((resolve, reject) => {
				let testReqInterval = setInterval(() => {
					http.getGlobalpingMeasurement(measurementId).then((testRes) => {
						if (isShareResCase) {
							let currentTargets = this.get('mainOptions.target');
							let currTargetsArr = _.removeDuplicatedTargets(currentTargets ? currentTargets.split(',') : []);
							let updTargetsArr = currTargetsArr.indexOf(testRes.target) < 0 ? [ ...currTargetsArr, testRes.target ] : currTargetsArr;

							this.set('mainOptions.target', updTargetsArr.join(','));

							// if infinite measurement we need to set targetsArr ASAP since we know there is only one target
							if (isInfiniteMeas) {
								this.set('targetsArr', updTargetsArr);
							}

							// only the first target's response returns locations
							if (isFirstShareReq) {
								let magicValue = testRes.locations?.reduce((res, loc) => {
									if (loc.magic) {
										res += res.length ? `, ${loc.magic}` : loc.magic;

										return res;
									}

									return res;
								}, '');

								this.set('mainOptions.location', magicValue);
							}

							if (isLastShareReq) {
								this.set('targetsArr', updTargetsArr);
								this.set('shareResHeaderData', `Showing results from ${_.formatDateTime(new Date(testRes.createdAt))}`);
								this.set('mainOptions.type', this.translateTestTypeName(testRes.type));
								this.set('mainOptions.limit', testRes.limit || DEFAULT_LIMIT);

								// handle map max timing for HTTP measurement
								if (testRes.type.toLowerCase() === 'http') {
									this.set('probesMaxTiming', 1000);
								}

								// ipVersion (target ip-type-switch) came with the measurementOptions but should be treated as the mainOptions
								if (testRes.measurementOptions?.ipVersion) {
									// if there is one target and it has IPv6 format (not a domain name) we shouldn't set ipVersion
									if (updTargetsArr.length !== 1 || !ipRegex.v6({ exact: true, allowBrackets: true }).test(updTargetsArr[0])) {
										this.set('mainOptions.ipVersion', testRes.measurementOptions.ipVersion);
									}

									delete testRes.measurementOptions.ipVersion;
								}

								let defaultAPIOpts = this.getDefaultAPIMeasOptsByTestName(testRes.type);
								let combinedOptions = _.deepExtend({}, defaultAPIOpts, testRes.measurementOptions);
								let receivedInitPresetOpts = this.filterForInitPresetOpts(defaultAPIOpts, combinedOptions);
								let receivedNotPresetOpts = this.filterForNotPresetOpts(defaultAPIOpts, combinedOptions);

								this.set('notAppliedOpts', receivedNotPresetOpts);
								this.set(`${testRes.type.toLowerCase()}Opts`, receivedInitPresetOpts);
								this.applyOptions();

								if (!isInfiniteMeas) {
									this.set('runTestBtnText', 'Run Again');
								}

								// clear qsMeasurementIdsArr so the mainOptions.type observer could work now
								this.set('qsMeasurementIdsArr', []);
							}
						}

						let isInfiniteMeasStopped = this.get('isInfiniteMeasStopped');

						// check if infinite measurement was stopped
						if (isInfiniteMeas && isInfiniteMeasStopped) {
							clearInterval(testReqInterval);
							resolve();
						}

						// prepare and set request params to pass them to gp-test-results
						let testReqParams = JSON.parse(JSON.stringify(testRes));

						delete testReqParams.results;
						delete testReqParams.status;
						delete testReqParams.updatedAt;
						delete testReqParams.createdAt;

						testReqParams = {
							inProgressUpdates: true,
							limit: DEFAULT_LIMIT,
							...testReqParams,
							measurementOptions: {
								trace: false,
								...testReqParams.measurementOptions,
							},
						};

						// set testReqParams to pass them to c-gp-results-raw-output
						this.set('testReqParams', testReqParams);

						// collect IDs of each target's measurement response
						let updMeasMetadata = {
							...this.get('measurementsMetadata'),
							[resNumber]: {
								target: testReqParams.target,
								measurementId: testReqParams.id,
							},
						};

						this.set('measurementsMetadata', updMeasMetadata);

						// set the local/client time of the response received
						let currentTimestamp = Date.now();
						let testResUpd = {
							...testRes,
							clientSideStartedAt: currentTimestamp,
							clientSideUpdatedAt: currentTimestamp,
						};

						// should be after the mainOptions.type was set
						this.set(`realTimeTestResResponse[${resNumber}]`, testResUpd);

						// handle infinite test flow, once at least one probe is finished we shuld run measurement again
						if (this.get('shareResFlow') === false && isInfiniteMeas && testRes.results.some(r => r.result.status === 'finished')) {
							let infiniteMeasIds = this.get('infiniteMeasIds');

							if (!infiniteMeasIds.includes(testRes.id)) {
								this.set('infiniteMeasIds', [ ...infiniteMeasIds, testRes.id ]);

								if (!isInfiniteMeasStopped) {
									this.postInfiniteGlobalpingMeasurement({
										reqParams,
										target: testRes.target,
										isInfiniteMeas: true,
										resNumber: infiniteMeasIds.length + 1,
									});
								}
							}
						}

						resolve(testRes);
					}).catch((e) => {
						clearInterval(testReqInterval);

						if (e.responseStatusCode === 404) {
							this.set('shareResHeaderData', 'This measurement has expired!');
							this.set('runTestBtnText', 'Run Test');
							this.scrollMapIntoView();
						}

						reject(e);
					});
				}, 1000);

				this.set(`testReqInterval[${resNumber}]`, testReqInterval);
			});
		},
		handleProbesResponse (isStored) {
			return (response) => {
				if (!isStored) {
					sessionStorage.setItem('probesResponse', JSON.stringify(response));
				} else {
					response = JSON.parse(response);
				}

				this.set('rawProbes', response);

				let { totalCities, totalCountries } = response.reduce((res, item) => {
					if (!res.citiesList.includes(item.location.city)) {
						res.citiesList.push(item.location.city);
					}

					if (!res.countriesList.includes(item.location.country)) {
						res.countriesList.push(item.location.country);
					}

					res.totalCities = res.citiesList.length;
					res.totalCountries = res.countriesList.length;

					return res;
				}, { citiesList: [], countriesList: [], totalCities: 0, totalCountries: 0 });

				this.animate('totalProbes', response.length, { duration: 2000 });
				this.animate('totalCities', totalCities, { duration: 2000 });
				this.animate('totalCountries', totalCountries, { duration: 2000 });
				this.set('probesResponse', this.groupProbes(response));
			};
		},
		translateTestTypeName (name) {
			switch (name.toLowerCase()) {
				case 'ping':
				case 'traceroute':
					return name.toLowerCase();
				case 'dns':
				case 'mtr':
				case 'http':
					return name.toUpperCase();
			}
		},
		getDefaultClientMeasOptsByTestName (name) {
			let res;

			switch (name.toLowerCase()) {
				case 'ping':
					res = this.get('infiniteSwitchEnabled') ? { ...CLIENT_DEFAULT_PING_OPTS, packets: INFINITE_MEASUREMENT_PACKETS } : CLIENT_DEFAULT_PING_OPTS; break;
				case 'traceroute':
					res = CLIENT_DEFAULT_TRACEROUTE_OPTS; break;
				case 'dns':
					res = CLIENT_DEFAULT_DNS_OPTS; break;
				case 'mtr':
					res = CLIENT_DEFAULT_MTR_OPTS; break;
				case 'http':
					res = CLIENT_DEFAULT_HTTP_OPTS; break;
			}

			// create deep copy to avoid mutations
			return JSON.parse(JSON.stringify(res));
		},
		getDefaultAPIMeasOptsByTestName (name) {
			let res;

			switch (name.toLowerCase()) {
				case 'ping':
					res = API_DEFAULT_PING_OPTS; break;
				case 'traceroute':
					res = API_DEFAULT_TRACEROUTE_OPTS; break;
				case 'dns':
					res = API_DEFAULT_DNS_OPTS; break;
				case 'mtr':
					res = API_DEFAULT_MTR_OPTS; break;
				case 'http':
					res = API_DEFAULT_HTTP_OPTS; break;
			}

			// create deep copy to avoid mutations
			return JSON.parse(JSON.stringify(res));
		},
		handleToggleMeasOpts () {
			if (this.get('testInProgress')) { return; }

			let prevValue = this.get('showMeasurementOpts');

			this.set('showMeasurementOpts', !prevValue);

			// if opts were not applied we should em reset to default or to prev applied state on closing of MeasOpts dropdown
			if (prevValue === true) {
				let testType = this.get('mainOptions.type');
				let appliedMeasOpts = this.get('appliedMeasOpts');
				let defaultOpts = this.getDefaultClientMeasOptsByTestName(testType);

				if (Object.keys(appliedMeasOpts).length) {
					this.set(`${testType.toLowerCase()}Opts`, { ...JSON.parse(JSON.stringify(appliedMeasOpts.initPresetOpts)) });
					this.set('notAppliedOpts', { ...JSON.parse(JSON.stringify(appliedMeasOpts.notPresetOpts)) });
				} else {
					this.set(`${testType.toLowerCase()}Opts`, defaultOpts);
					this.set('notAppliedOpts', {});
				}
			}
		},
		countModifiedMeasurementOpts (type, initPresetOpts, notPresetOpts) {
			let defaultOpts = this.getDefaultClientMeasOptsByTestName(type);
			let modifiedMeasOptsCnt = Object.keys(notPresetOpts).reduce((cnt, key) => {
				if (typeof notPresetOpts[key] === 'object') {
					if (key === 'request' && notPresetOpts[key].headers) {
						// each header should be treated as 1 modified option
						let headersCnt = Object.keys(notPresetOpts[key].headers).length;
						let otherPropsCnt = Object.keys(notPresetOpts[key]).length - 1; // -1 for headers

						return cnt + headersCnt + otherPropsCnt;
					}

					return cnt + Object.keys(notPresetOpts[key]).length;
				} else if (defaultOpts[key] !== notPresetOpts[key]) {
					return ++cnt;
				}

				return cnt;
			}, 0);

			Object.keys(defaultOpts).forEach((key) => {
				if (typeof defaultOpts[key] === 'object') {
					Object.keys(defaultOpts[key]).forEach((secKey) => {
						if (defaultOpts[key][secKey] !== initPresetOpts[key][secKey]) {
							modifiedMeasOptsCnt++;
						}
					});
				} else if (defaultOpts[key] !== initPresetOpts[key] && defaultOpts[key] !== notPresetOpts[key]) {
					modifiedMeasOptsCnt++;
				}
			});

			this.set('modifiedMeasOptsCnt', modifiedMeasOptsCnt);
		},
		resetMapAndRunTest (prevProbesMeasId = null) {
			let mq = window.matchMedia('(min-width: 768px)');

			if (mq.matches) {
				map.setCenter(MAP_CENTER_ALT);
				map.setZoom(MAP_ZOOM_ALT);
			} else {
				map.setCenter(MAP_CENTER_REG);
				map.setZoom(MAP_ZOOM_REG);
			}

			// once zoom is ended the idle event will be fired
			map.addListener('idle', () => {
				this.proceedToTest(prevProbesMeasId);
				// remove listener to avoid unintended test runs while zoom
				google.maps.event.clearListeners(map, 'idle');
			});
		},
		filterForInitPresetOpts (defaultOpts, optionsToFilter) {
			return Object.keys(optionsToFilter).reduce((res, key) => {
				if (Object.hasOwn(defaultOpts, key)) {
					if (typeof defaultOpts[key] === 'object') {
						res = {
							...res,
							[key]: this.filterForInitPresetOpts(defaultOpts[key], optionsToFilter[key]),
						};
					} else {
						res = {
							...res,
							[key]: optionsToFilter[key],
						};
					}
				}

				return res;
			}, {});
		},
		filterForNotPresetOpts (defaultOpts, optionsToFilter) {
			return Object.keys(optionsToFilter).reduce((res, key) => {
				if (Object.hasOwn(defaultOpts, key)) {
					if (typeof optionsToFilter[key] === 'object') {
						res = {
							...res,
							[key]: this.filterForNotPresetOpts(defaultOpts[key], optionsToFilter[key]),
						};
					}
				} else {
					res = {
						...res,
						[key]: optionsToFilter[key],
					};
				}

				return res;
			}, {});
		},
		zoomToResults (locations) {
			setTimeout(() => {
				// do not zoom if test was done for the World.
				if (
					!locations
					|| (
						locations.length === 1
							&& (locations[0].magic.toLowerCase() === 'world' || locations[0].magic === '')
					)
				) {
					return;
				}

				// limit max zoom temp to avoid unnecessary zooming
				map.setOptions({ maxZoom: 6 });

				let bounds = new google.maps.LatLngBounds();

				mapMarkers.forEach((mm) => {
					bounds.extend(mm.position);
				});

				google.maps.event.addListenerOnce(map, 'bounds_changed', () => {
					map.panTo(bounds.getCenter());
					// restore default zoom
					map.setOptions({ maxZoom: MAP_MAX_ZOOM });
				});

				map.fitBounds(bounds);
			}, 400);
		},
		getProbesData () {
			if (has.sessionStorage()) {
				let probesResponse = sessionStorage.getItem('probesResponse');

				if (probesResponse) {
					this.handleProbesResponse(true)(probesResponse);
				} else {
					http.fetchGlobalpingProbes().then(this.handleProbesResponse(false));
				}
			} else {
				http.fetchGlobalpingProbes().then(this.handleProbesResponse(false));
			}
		},
		scrollMapIntoView () {
			let mapBlockEl = this.find('.gp_map-block');

			mapBlockEl.scrollIntoView({
				behavior: 'smooth',
			});
		},
		updateMapMarkerWithIW (marker, markerData, currentMarkerIdx) {
			let updSvg = this.createMapMarkerSvg(markerData);
			let currIw = infoWindows[currentMarkerIdx];

			marker.content.style.backgroundImage = `url('data:image/svg+xml;base64,${updSvg}')`;

			currIw.setContent(this.createInfoWindowContent(markerData, currentMarkerIdx));
		},
		createMapMarkerWithIW (markerData, currentMarkerIdx) {
			// create Popup element which will be shown on click on the marker
			let infoWindow = new google.maps.InfoWindow();

			// create svg to use as a Marker icon
			let svg = this.createMapMarkerSvg(markerData);

			// add listener to IW for Results and Actions button
			google.maps.event.addListener(infoWindow, 'domready', () => {
				let clickableEl = document.getElementById(`iw-${currentMarkerIdx}`);
				let hasListener = clickableEl.dataset.hasListener;

				if (!hasListener) {
					clickableEl.addEventListener('click', () => {
						this.handleSeeResults(currentMarkerIdx);
						clickableEl.dataset.hasListener = true;
					});
				}
			});

			// collect IWs
			infoWindows.push(infoWindow);
			infoWindow.setContent(this.createInfoWindowContent(markerData, currentMarkerIdx));

			let markerContent = document.createElement('div');
			markerContent.style.backgroundImage = `url('data:image/svg+xml;base64,${svg}')`;
			markerContent.style.width = `${DEFAULT_MARKER_DIMENSIONS}px`;
			markerContent.style.height = `${DEFAULT_MARKER_DIMENSIONS}px`;
			markerContent.style.backgroundRepeat = 'no-repeat';
			markerContent.style.backgroundPosition = 'center';
			markerContent.style.backgroundSize = 'contain';

			// create a new Marker
			let marker = new google.maps.marker.AdvancedMarkerElement({
				map,
				content: markerContent,
				position: { lat: markerData.lat, lng: markerData.lng },
				zIndex: 1,
			});

			// keep original markers positions
			originalMapMarkersPos.set(marker, marker.position);

			mapMarkers.push(marker);

			// open IW on click, close all other IWs, handle markers spiderifying
			marker.addListener('click', () => {
				infoWindows.forEach(iw => iw.close());

				// check if marker is overlapping with other and should be spiderified
				if (this.shouldMapMarkersSpiderify(marker, mapMarkers, map) && marker.isSpiderPart !== true) {
					// despiderify markers
					this.despiderifyMapMarkers(mapMarkers);
					// spiderify overlapping markers
					this.spiderifyMapMarkers(marker, mapMarkers, map);
				} else {
					// open InfoWindow if marker is already spiderified or do not needed to be
					infoWindow.open({ map, anchor: marker });
				}
			});
		},
		async getMultipleTestMeasurementById (idsArr, isInfiniteMeas = false) {
			for (let i = 0; i < idsArr.length; i++) {
				await this.getTestMeasurementById({
					measurementId: idsArr[i],
					resNumber: i,
					isShareResCase: true,
					isFirstShareReq: i === 0,
					isLastShareReq: idsArr.length - 1 === i,
					isInfiniteMeas,
				});
			}
		},
		postInfiniteGlobalpingMeasurement ({ reqParams, target, isInfiniteMeas = true, resNumber = 0 }) {
			this.set('runTestBtnText', 'Stop');

			http.postGlobalpingMeasurement({ ...reqParams, target }, RATE_LIMIT_HEADERS).then((res) => {
				// set response headers for gp-credits/gp-credits-message
				this.set('rateCreditsData', { ...res.responseHeaders, probesCount: res.response.probesCount });

				// set measurement ID for re-use probes case
				this.set('prevProbesMeasId', res.response.id);

				// Update the URL.
				if (resNumber === 0) {
					this.set('measurement', res.response.id);
				} else {
					app.router.replaceQueryParam('measurement', `${this.get('measurement').split('.').slice(-9).join('.')}.${res.response.id}`);
				}

				let updReqParams = {
					...reqParams,
					locations: res.response.id,
				};

				this.getTestMeasurementById({ measurementId: res.response.id, resNumber, isInfiniteMeas, reqParams: updReqParams });
				this.set('showMap', this.get('originalShowMap'));
			}).catch((err) => {
				this.handlePostGPMeasError(err);
			});
		},
		isInfiniteOptsCorrect () {
			let { type, target } = this.get('mainOptions');

			return type === 'ping' && target.split(',').length <= 1;
		},
		handleInfiniteSwitch () {
			if (this.get('testInProgress') || !this.isInfiniteOptsCorrect()) { return; }

			let infiniteSwitchEnabled = this.get('infiniteSwitchEnabled');

			if (infiniteSwitchEnabled) {
				this.set('notAppliedOpts.packets', '');
			} else {
				this.set('notAppliedOpts.packets', INFINITE_MEASUREMENT_PACKETS);
			}

			this.set('infiniteSwitchEnabled', !infiniteSwitchEnabled);
			this.applyOptions();
		},
		handleInfiniteSwitchKeyDown (e) {
			if (e.key === 'Enter') {
				this.handleInfiniteSwitch();
			}
		},
		handleInfiniteMeasBtn () {
			let testInProgress = this.get('testInProgress');

			if (testInProgress) {
				this.stopInfiniteTest();
			} else {
				this.resetMapAndRunTest();
			}
		},
		stopInfiniteTest () {
			this.set('testInProgress', false);
			this.set('isInfiniteMeasStopped', true);
			this.set('runTestBtnText', 'Run Again');
		},
		handlePostGPMeasError (err) {
			let isInfiniteModeRes = this.get('isInfiniteModeRes');
			let testResults = this.get('testResults');

			this.set('testInProgress', false);
			// we show the error block under the map block only if it is not an infinite measurement or the one with no results
			this.set('runTestBtnText', 'Run Test');
			// set response headers (from error) for gp-credits/gp-credits-message
			this.set('rateCreditsData', err.responseHeaders);

			if (err.responseStatusCode === 429) {
				let measurementErrMsg = _.createMeasCreditsErrMsg(
					err.responseHeaders,
					this.get('@shared.user'),
					isInfiniteModeRes,
					!!testResults,
				);

				this.set('measurementErrMsg', measurementErrMsg);

				if (isInfiniteModeRes && testResults) {
					this.set('showCreditsError', true);
				} else {
					this.set('showCreditsData', false);
					this.set('showMap', false);
				}
			} else if (err.error.type === 'validation_error') {
				let measurementOptsErr = Object.keys(err.error.params || {}).some(key => key.split('.')[0] === 'measurementOptions');
				let inputErrors = _.parseValidationErrors(err.error);

				this.set('inputErrors', inputErrors);

				// open measurement options menu if it contains errors
				if (measurementOptsErr) {
					this.set('showMeasurementOpts', true);
				}
			} else {
				this.set('measurementErrMsg', err.error.message);
				this.set('showMap', false);
			}
		},
		reUseProbesRunTest () {
			let prevProbesMeasId = this.get('prevProbesMeasId');

			this.resetMapAndRunTest(prevProbesMeasId);
		},
		handleDropDownRunTestBtnNav () {
			// set this handler only once
			if (this.get('ddHandlerSet')) { return; }

			setTimeout(() => {
				let dropdownComponent = document.getElementById('dd-run-test-btn');

				dropdownComponent.addEventListener('focusout', (event) => {
					let dropdownMenu = dropdownComponent.querySelector('.dropdown-menu');
					let button = dropdownComponent.querySelector('.dropdown-toggle');
					let buttonWrapper = dropdownComponent.querySelector('.gp_map-block_settings-wrapper_split-btn');

					if (dropdownMenu && event.relatedTarget && !dropdownMenu.contains(event.relatedTarget)) {
						dropdownMenu.querySelectorAll('.dropdown-item').forEach(item => item.classList.remove('active'));
						button.setAttribute('aria-expanded', false);
						buttonWrapper.classList.remove('open');
					}
				});

				dropdownComponent.addEventListener('keydown', (event) => {
					let dropdownMenu = dropdownComponent.querySelector('.dropdown-menu');
					let activeItem = dropdownComponent.querySelector('.dropdown-item.active');
					let button = dropdownComponent.querySelector('.dropdown-toggle');

					if (dropdownMenu) {
						if (event.key === 'ArrowDown' || event.key === 'ArrowUp') {
							if (!activeItem) {
								let firstItem = dropdownMenu.firstElementChild;

								if (firstItem) {
									firstItem.classList.add('active');
								}
							} else {
								let nextItem;

								if (event.key === 'ArrowDown') {
									nextItem = activeItem.nextElementSibling;
								} else if (event.key === 'ArrowUp') {
									nextItem = activeItem.previousElementSibling;
								}

								if (nextItem) {
									activeItem.classList.remove('active');

									nextItem.classList.add('active');
								} else if (event.key === 'ArrowUp') {
									activeItem.classList.remove('active');
									button.focus();
								}
							}
						} else if (event.key === 'Enter' && activeItem) {
							activeItem.click();
						}
					}
				});

				this.set('ddHandlerSet', true);
			}, 4);
		},
		createMapMarkerSvg (markerData) {
			let svg;
			let svgFillColors = [];
			let targetsCnt = this.get('targetsArr').length;
			let probesMaxTiming = this.get('probesMaxTiming');
			let probesMinTiming = this.get('probesMinTiming');

			for (let i = 0; i < targetsCnt; i++) {
				svgFillColors.push(markerData.timings[i] ? _.getGpProbeStatusColor(markerData.timings[i], probesMaxTiming, probesMinTiming) : DEFAULT_MARKER_COLOR);
			}

			if (markerData.timings.length > 1) {
				svg = window.btoa(`<svg width="${DEFAULT_MARKER_DIMENSIONS}" height="${DEFAULT_MARKER_DIMENSIONS}" viewBox="0 0 ${DEFAULT_MARKER_DIMENSIONS} ${DEFAULT_MARKER_DIMENSIONS}" fill="none" xmlns="http://www.w3.org/2000/svg">
					<g filter="url(#filter0_d_6106_3045)">
					<circle cx="12" cy="10" r="6" fill="${svgFillColors[1]}"/>
					<clipPath id="cut-off">
					<rect x="6" y="4" width="6" height="1112"/>
					</clipPath>
					<circle cx="12" cy="10" r="6" fill="${svgFillColors[0]}" clip-path="url(#cut-off)"/>
					<circle cx="12" cy="10" r="7" stroke="white" stroke-width="2"/>
					</g>
					<defs>
					<filter id="filter0_d_6106_3045" x="0" y="0" width="${DEFAULT_MARKER_DIMENSIONS}" height="${DEFAULT_MARKER_DIMENSIONS}" filterUnits="userSpaceOnUse" color-interpolation-filters="sRGB">
					<feFlood flood-opacity="0" result="BackgroundImageFix"/>
					<feColorMatrix in="SourceAlpha" type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0" result="hardAlpha"/>
					<feOffset dy="2"/>
					<feGaussianBlur stdDeviation="2"/>
					<feComposite in2="hardAlpha" operator="out"/>
					<feColorMatrix type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.2 0"/>
					<feBlend mode="normal" in2="BackgroundImageFix" result="effect1_dropShadow_6106_3045"/>
					<feBlend mode="normal" in="SourceGraphic" in2="effect1_dropShadow_6106_3045" result="shape"/>
					</filter>
					</defs>
					</svg>`);
			} else {
				svg = window.btoa(`<svg width="${DEFAULT_MARKER_DIMENSIONS}" height="${DEFAULT_MARKER_DIMENSIONS}" viewBox="0 0 ${DEFAULT_MARKER_DIMENSIONS} ${DEFAULT_MARKER_DIMENSIONS}" fill="none" xmlns="http://www.w3.org/2000/svg">
					<g filter="url(#filter0_d_6106_3045)">
					<circle cx="12" cy="10" r="6" fill="${svgFillColors[0]}"/>
					<circle cx="12" cy="10" r="7" stroke="white" stroke-width="2"/>
					</g>
					<defs>
					<filter id="filter0_d_6106_3045" x="0" y="0" width="${DEFAULT_MARKER_DIMENSIONS}" height="${DEFAULT_MARKER_DIMENSIONS}" filterUnits="userSpaceOnUse" color-interpolation-filters="sRGB">
					<feFlood flood-opacity="0" result="BackgroundImageFix"/>
					<feColorMatrix in="SourceAlpha" type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0" result="hardAlpha"/>
					<feOffset dy="2"/>
					<feGaussianBlur stdDeviation="2"/>
					<feComposite in2="hardAlpha" operator="out"/>
					<feColorMatrix type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.2 0"/>
					<feBlend mode="normal" in2="BackgroundImageFix" result="effect1_dropShadow_6106_3045"/>
					<feBlend mode="normal" in="SourceGraphic" in2="effect1_dropShadow_6106_3045" result="shape"/>
					</filter>
					</defs>
					</svg>`);
			}

			return svg;
		},
		createInfoWindowContent (markerData, currentMarkerIdx) {
			let targetsCnt = this.get('targetsArr').length;
			let probesMaxTiming = this.get('probesMaxTiming');
			let probesMinTiming = this.get('probesMinTiming');
			let infoWindowContent = '<div class="gp-map_popup">';

			infoWindowContent += `<div class="gp-map_popup${targetsCnt > 1 ? '_multi' : '_single'}">`;

			if (targetsCnt === 1) {
				infoWindowContent += `<div class="gp-map_popup_single_timing">${markerData.timings[0] || ''}</div>`;
				infoWindowContent += `<div class="gp-map_popup_single_network">${markerData.network}</div>`;
				infoWindowContent += `<div class="gp-map_popup_single_location">(${markerData.city}, ${markerData.country})</div>`;
			} else {
				infoWindowContent += `<div class="gp-map_popup_multi_network">${markerData.network}</div>`;
				infoWindowContent += `<div class="gp-map_popup_multi_location">(${markerData.city}, ${markerData.country})</div>`;

				markerData.targets.forEach((target, targetIdx) => {
					infoWindowContent += '<div class="gp-map_popup_multi_data">';
					infoWindowContent += `<span class="gp-map_popup_multi_data_target">${target}</span>`;

					infoWindowContent += `<span class="gp-map_popup_multi_data_timing"
						style='color: ${_.getGpProbeStatusColor(markerData.timings[targetIdx], probesMaxTiming, probesMinTiming)}'>${markerData.timings[targetIdx] || ''}</span>`;

					infoWindowContent += '</div>';
				});
			}

			infoWindowContent += '</div>';
			infoWindowContent += `<div class="gp-map_popup_see-results ${targetsCnt > 1 ? 'centered' : ''}" id="iw-${currentMarkerIdx}">`;
			infoWindowContent += `<img width="20" height="20" src="${this.get('@shared.assetsHost')}/img/globalping/see-results-icon.svg">`;
			infoWindowContent += '<span>Results and Actions</span>';
			infoWindowContent += '</div>';
			infoWindowContent += '</div>';

			return infoWindowContent;
		},
		prepareRegularResults (testResults) {
			return testResults.reduce((prepResults, resArr, resArrIdx) => {
				let dnsTraceEnabled = this.get('testReqParams.measurementOptions.trace');

				if (resArrIdx === 0) {
					return resArr.map((res) => {
						let preparedRes = {
							clientSideId: res.clientSideId,
							...res.probe,
							statsPerTarget: [{
								target: res.target,
							}],
						};

						if (res.result.status !== 'in-progress') {
							let { isFailed = false, lastTiming, value: avgTiming, extraValues } = _.calcGpTestResTiming(res.type, res, dnsTraceEnabled);
							let { packetsRtt, packetsTotal } = _.parseGpRawOutputForTimings(res.result.rawOutput);
							let minTiming = res.result?.stats?.min || PROBE_NO_TIMING_VALUE;
							let maxTiming = res.result?.stats?.max || PROBE_NO_TIMING_VALUE;
							let statsTotal = res.result?.stats?.total;
							let statsDrop = res.result?.stats?.drop;
							let isOffline = res.result.status === PROBE_STATUS_OFFLINE;

							preparedRes.statsPerTarget = [{
								...preparedRes.statsPerTarget[0],
								ipAddr: res.result.resolvedAddress,
								lastTiming,
								minTiming,
								avgTiming,
								maxTiming,
								statsTotal,
								statsDrop,
								isFailed,
								isOffline,
								packetsRtt,
								extraValues,
								failureRawOutput: this.getFailureProbeRawOutput(res),
								rawOutput: res.result.rawOutput,
								qualityStr: this.createQualityString(isOffline, statsTotal, statsDrop),
								areTimingsReady: this.checkAreTimingsReady(lastTiming, maxTiming, minTiming, avgTiming, packetsTotal),
								tls: res.result.tls,
							}];
						}

						return preparedRes;
					});
				}

				return prepResults.map((pR) => {
					let nextReqRes = resArr.find(rA => rA.clientSideId === pR.clientSideId);

					if (nextReqRes) {
						let preparedNextRes = {
							...pR,
							statsPerTarget: [
								...pR.statsPerTarget,
								{
									target: nextReqRes.target,
								},
							],
						};

						if (nextReqRes.result.status !== 'in-progress') {
							let { isFailed = false, lastTiming, value: avgTiming, extraValues } = _.calcGpTestResTiming(nextReqRes.type, nextReqRes, dnsTraceEnabled);
							let { packetsRtt, packetsTotal } = _.parseGpRawOutputForTimings(nextReqRes.result.rawOutput);
							let minTiming = nextReqRes.result?.stats?.min || PROBE_NO_TIMING_VALUE;
							let maxTiming = nextReqRes.result?.stats?.max || PROBE_NO_TIMING_VALUE;
							let statsTotal = nextReqRes.result?.stats?.total;
							let statsDrop = nextReqRes.result?.stats?.drop;
							let isOffline = nextReqRes.result.status === PROBE_STATUS_OFFLINE;

							preparedNextRes.statsPerTarget = [
								...pR.statsPerTarget,
								{
									...preparedNextRes.statsPerTarget[1],
									ipAddr: nextReqRes.result.resolvedAddress,
									lastTiming,
									minTiming,
									avgTiming,
									maxTiming,
									statsTotal,
									statsDrop,
									isFailed,
									isOffline,
									packetsRtt,
									extraValues,
									failureRawOutput: this.getFailureProbeRawOutput(nextReqRes),
									rawOutput: nextReqRes.result.rawOutput,
									qualityStr: this.createQualityString(isOffline, statsTotal, statsDrop),
									areTimingsReady: this.checkAreTimingsReady(lastTiming, maxTiming, minTiming, avgTiming, packetsTotal),
								},
							];
						}

						return preparedNextRes;
					}

					return pR;
				});
			}, []);
		},
		prepareInfiniteResults (rawResults) {
			let probesAmount = rawResults[0].length;
			let probesMeasurements = [];

			// gather probe's data from different measurements, with each sub array representing a single probe's data
			for (let i = 0; i < probesAmount; i++) {
				probesMeasurements.push(rawResults.map(rr => rr[i]));
			}

			// prepare data for gp-raw-output, gp-table-output components
			return probesMeasurements.map((pbm) => {
				return pbm.reduce((combinedProbeData, probeData) => {
					let { packetsRtt, packetsDrop, packetsTotal } = _.parseGpRawOutputForTimings(probeData.result.rawOutput);
					let isOffline = probeData.result.status === PROBE_STATUS_OFFLINE;
					let packetsRttCombined = [ ...combinedProbeData.packetsRtt || [], ...packetsRtt ];
					let packetsDropCombined = (combinedProbeData.packetsDrop || 0) + packetsDrop;
					let packetsTotalCombined = (combinedProbeData.packetsTotal || 0) + packetsTotal;
					let numericPacketsRttCombined = packetsRttCombined.filter(v => typeof v === 'number');
					let maxTiming = numericPacketsRttCombined.length ? Math.max(...numericPacketsRttCombined) : PROBE_NO_TIMING_VALUE;
					let minTiming = numericPacketsRttCombined.length ? Math.min(...numericPacketsRttCombined) : PROBE_NO_TIMING_VALUE;
					let avgTiming = numericPacketsRttCombined.length
						? Number((numericPacketsRttCombined.reduce((res, rtt) => res += rtt, 0) / numericPacketsRttCombined.length).toFixed(2))
						: PROBE_NO_TIMING_VALUE;
					let lastTiming = packetsRttCombined[packetsRttCombined.length - 1] || PROBE_NO_TIMING_VALUE;
					let lossValue = this.calcLoss(packetsRttCombined.length + packetsDropCombined, packetsDropCombined);
					let { packetLines, linesHeader, lastLineIdx } = this.parseLinesFromRawOutput(
						probeData.result.rawOutput,
						combinedProbeData.lastLineIdx || 0,
					);
					let outputLinesCombined = [ ...combinedProbeData.rawOutputLines || [], ...packetLines ];
					let ipAddr = combinedProbeData.ipAddr || this.parseIPFromRawOutput(probeData.result.rawOutput);
					let rawOutputCombined = this.handleRawOutput([ linesHeader, ...outputLinesCombined ]);
					let clientSideMeasTime = probeData.clientSideUpdatedAt - probeData.clientSideStartedAt;
					let measurementTimeCombined = combinedProbeData.measurementTime || 0;

					// if measurement is finished we should take a server time (updatedAt - createdAt)
					if (probeData.status === 'finished') {
						measurementTimeCombined += probeData.serverTime;
					} else {
						// otherwise we should take a local time
						measurementTimeCombined += clientSideMeasTime;
					}

					return {
						...combinedProbeData,
						lastLineIdx,
						packetsRtt: packetsRttCombined,
						packetsDrop: packetsDropCombined,
						packetsTotal: packetsTotalCombined,
						rawOutputLines: outputLinesCombined,
						measurementTime: measurementTimeCombined,
						ipAddr,
						clientSideId: probeData.clientSideId,
						...probeData.probe,
						statsPerTarget: [{
							target: probeData.target,
							ipAddr,
							lastTiming,
							minTiming,
							avgTiming,
							maxTiming,
							statsTotal: packetsRttCombined.length,
							statsDrop: packetsDropCombined,
							isFailed: probeData.result.status === PROBE_STATUS_FAILED,
							isOffline,
							failureRawOutput: this.getFailureProbeRawOutput(probeData),
							packetsRtt: packetsRttCombined,
							qualityStr: this.createQualityString(isOffline, numericPacketsRttCombined.length + packetsDropCombined, packetsDropCombined),
							areTimingsReady: this.checkAreTimingsReady(lastTiming, maxTiming, minTiming, avgTiming, packetsTotalCombined),
							rawOutput: rawOutputCombined,
							extraValues: lossValue !== null ? { loss: { text: 'Loss', value: lossValue, units: '%' } } : {},
							rawFooter: this.createRawFooter(
								probeData.target,
								numericPacketsRttCombined,
								packetsTotalCombined,
								numericPacketsRttCombined.length,
								lossValue,
								minTiming,
								avgTiming,
								maxTiming,
								measurementTimeCombined,
								rawOutputCombined,
							),
						}],
					};
				}, {});
			});
		},
		getFailureProbeRawOutput (probeData) {
			let rawOutput;
			let { status = null } = probeData.result;

			if (status === PROBE_STATUS_OFFLINE || status === PROBE_STATUS_FAILED) {
				rawOutput = probeData.result.rawOutput;
			}

			return rawOutput;
		},
		createQualityString (isOffline, statsTotal, statsDrop) {
			if (isOffline) { return PROBE_OFFLINE_TEXT; }

			let { actualAmount, qualityPercentage } = this.calcQuality(statsTotal, statsDrop);

			return qualityPercentage !== null ? `${actualAmount}/${statsTotal} - ${qualityPercentage}%` : '';
		},
		checkAreTimingsReady (lastTiming, maxTiming, minTiming, avgTiming, packetsTotal) {
			if (
				!packetsTotal
				|| typeof lastTiming === 'undefined'
				|| typeof maxTiming === 'undefined'
				|| typeof minTiming === 'undefined'
				|| typeof avgTiming === 'undefined'
			) {
				return false;
			}

			return true;
		},
		calcQuality (statsTotal, statsDrop) {
			if (
				typeof statsTotal === 'undefined'
				|| typeof statsDrop === 'undefined'
				|| statsTotal === 0
			) {
				return {
					qualityPercentage: null,
					actualAmount: null,
				};
			}

			let actualAmount = Math.max(statsTotal - statsDrop, 0);
			let qualityPercentage = Math.round(actualAmount / statsTotal * 100);

			return {
				qualityPercentage,
				actualAmount,
			};
		},
		parseIPFromRawOutput (raw) {
			let regex = ipRegex();
			let match = raw.match(regex);

			if (match) {
				return match[0];
			}

			return '';
		},
		parseLinesFromRawOutput (raw, idxShift = 0) {
			let lines = raw.split('\n').filter(l => l);
			let linesHeader;
			let packetLines = [];
			let lastLineIdx = idxShift;

			for (let i = 0; i < lines.length; i++) {
				if (i === 0) {
					linesHeader = lines[i];

					continue;
				}

				if (lines[i].includes('---')) { break; }

				let subRegex = /(icmp_seq|tcp_conn)=(\d+)/;
				let match = lines[i].match(subRegex);
				let proto = match[1];
				let originalIdx = Number(match[2]);
				lastLineIdx = idxShift + originalIdx;
				let substitute = `${proto}=${lastLineIdx}`;
				let numberedLine = lines[i].replace(subRegex, substitute);

				packetLines.push(numberedLine);
			}

			return {
				packetLines,
				linesHeader,
				lastLineIdx,
			};
		},
		calcLoss (statsTotal, statsDrop) {
			if (
				typeof statsTotal === 'undefined'
				|| typeof statsDrop === 'undefined'
				|| statsTotal === 0
			) {
				return null;
			}

			let actualAmount = Math.max(statsTotal - statsDrop, 0);

			return Math.round(statsDrop / actualAmount * 100);
		},
		handleRawOutput (lines) {
			let limitedLines = lines.length > RAW_OUTPUT_LINES_BATCH_LIMIT ? [ '...', ...lines.slice(-RAW_OUTPUT_LINES_BATCH_LIMIT) ] : lines;

			return limitedLines.join('\n');
		},
		setMainOptsTestType (newTestType) {
			if (this.get('testInProgress')) { return; }

			this.set('mainOptions.type', newTestType);
		},
		createRawFooter (
			target,
			rtts,
			packetsTotal,
			packetsReceived,
			lossValue,
			minTiming,
			avgTiming,
			maxTiming,
			time,
			rawOutput = '',
		) {
			let mdev = this.calculateMeanDeviation(rtts);
			let showRttUnits = [ minTiming, avgTiming, maxTiming, mdev ].some(i => i !== PROBE_NO_TIMING_VALUE);
			let str = `${rawOutput ? '\n' : ''}--- ${target} ping statistics ---
${packetsTotal} packets transmitted, ${packetsReceived} received, ${lossValue || 0}% packet loss, time ${time}ms
rtt min/avg/max/mdev = ${minTiming}/${avgTiming}/${maxTiming}/${mdev}${showRttUnits ? ' ms' : ''}`;

			return str;
		},
		calculateMeanDeviation (rtts) {
			if (rtts.length === 0) {
				return PROBE_NO_TIMING_VALUE;
			}

			let rttsNumber = rtts.length;
			let rttsSquaredSum = rtts.reduce((sum, rtt) => sum + rtt * rtt, 0);
			let rttsSum = rtts.reduce((sum, rtt) => sum + rtt, 0);
			let mdev = Math.sqrt(rttsSquaredSum / rttsNumber - Math.pow(rttsSum / rttsNumber, 2));

			return Math.round(mdev * 1000) / 1000;
		},
		groupProbes (probes) {
			// group probes by Continents and Coordinates
			let groups = probes.reduce((res, probe) => {
				let coords = `${probe.location.latitude}, ${probe.location.longitude}`;

				// group by Coordinates
				if (!Object.hasOwn(res, coords)) {
					res[coords] = [];
				}

				res[coords].push(probe);

				return res;
			}, {});

			return groups;
		},
		createMapClusterMarkerWithIW (key, markersByCoords) {
			let [ lat, lng ] = key.split(', ');
			let svg = this.createClusterMarkerSVG(markersByCoords.length);
			let probeInfoWindow = new google.maps.InfoWindow();

			// Collect InfoWindows
			probesInfoWindows.push(probeInfoWindow);
			probeInfoWindow.setContent(this.createClusterMarkerInfoWindowContent(markersByCoords));

			let markerContent = document.createElement('div');
			markerContent.style.backgroundImage = `url('data:image/svg+xml;base64,${svg}')`;
			markerContent.style.backgroundRepeat = 'no-repeat';
			markerContent.style.backgroundPosition = 'center';
			markerContent.style.backgroundSize = 'contain';
			markerContent.setAttribute('data-probe-count', markersByCoords.length);

			let { svgWidth, svgHeight } = getMarkerSize(markersByCoords.length, map.zoom);
			markerContent.style.width = `${svgWidth}px`;
			markerContent.style.height = `${svgHeight}px`;

			let probeMarker = new google.maps.marker.AdvancedMarkerElement({
				map,
				content: markerContent,
				position: { lat: Number(lat), lng: Number(lng) },
				zIndex: 1,
			});

			probeMarker.addListener('click', () => {
				probesInfoWindows.forEach(iw => iw.close());
				probeInfoWindow.open({ map, anchor: probeMarker });
			});

			probeMarker.markersCount = markersByCoords.length || 0;

			return probeMarker;
		},
		createClusterMarkerInfoWindowContent (markersByCoords) {
			let markersCnt = markersByCoords.length;
			let groupedNetworks = markersByCoords.reduce((res, m) => {
				let marker = res.find(i => i.location.network === m.location.network);

				if (marker) {
					marker.cnt += 1;
				} else {
					res.push({ ...m, cnt: 1, sortKey: m.location.network.toLowerCase() });
				}

				return res;
			}, []).sort((a, b) => a.sortKey < b.sortKey ? -1 : a.sortKey > b.sortKey);

			let infoWindowContent = `<div class="gp_map-cluster-iw">`;

			if (markersCnt === 1) {
				let { network, city, country } = markersByCoords[0].location;

				infoWindowContent += `<span>${network} (${city}, ${country})</span>`;
			} else {
				// in this case we should render a list of probes
				groupedNetworks.forEach((m, mIdx) => {
					if (mIdx === 0) {
						// add header content
						infoWindowContent += '<span class="gp_map-cluster-iw_header">';
						infoWindowContent += `<img width="16" height="16" src="${this.get('@shared.assetsHost')}/img/globalping/location-icon.svg">`;
						infoWindowContent += `<span class="gp_map-cluster-iw_header_location">${m.location.city}, ${m.location.country}</span>`;
						infoWindowContent += `<span class="gp_map-cluster-iw_header_cnt">${markersByCoords.length}</span>`;
						infoWindowContent += '</span>';
					}

					// render the list of the probes, grouped by the same network
					infoWindowContent += `<span class="gp_map-cluster-iw_row">${m.location.network} ${m.cnt > 1 ? `<span class="gp_map-cluster-iw_row_network-cnt">${m.cnt}</span>` : ''}</span>`;
				});
			}

			infoWindowContent += '</div>';

			return infoWindowContent;
		},
		createClusterMarkerSVG (elementsCnt) {
			let { svgWidth, svgHeight, circleRadius, strokeWidth } = getMarkerSize(elementsCnt, 1); // here zoom must always be 1

			return window.btoa(`
				<svg width="${svgWidth}" height="${svgHeight}" viewBox="0 0 ${svgWidth} ${svgHeight}" fill="none" xmlns="http://www.w3.org/2000/svg">
					<g filter="url(#filter0_d_6106_3045)">
						<circle cx="${svgWidth / 2}" cy="${svgHeight / 2}" r="${circleRadius}" fill="#17D4A7"/>
						<circle cx="${svgWidth / 2}" cy="${svgHeight / 2}" r="${circleRadius + 1}" stroke="white" stroke-width="${strokeWidth}"/>
					</g>
					${elementsCnt !== 1 ? `<text x="${svgWidth / 2}" y="${svgHeight / 2}" text-anchor="middle" dy=".35em" font-family="Arial" font-size="10" font-weight="bold" fill="#fff">${elementsCnt}</text>` : ''}
					<defs>
						<filter id="filter0_d_6106_3045" x="0" y="0" width="${svgWidth}" height="${svgHeight}" filterUnits="userSpaceOnUse" color-interpolation-filters="sRGB">
							<feFlood flood-opacity="0" result="BackgroundImageFix"/>
							<feColorMatrix in="SourceAlpha" type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0" result="hardAlpha"/>
							<feOffset dy="1"/>
							<feGaussianBlur stdDeviation="1"/>
							<feComposite in2="hardAlpha" operator="out"/>
							<feColorMatrix type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.2 0"/>
							<feBlend mode="normal" in2="BackgroundImageFix" result="effect1_dropShadow_6106_3045"/>
							<feBlend mode="normal" in="SourceGraphic" in2="effect1_dropShadow_6106_3045" result="shape"/>
						</filter>
					</defs>
				</svg>
			`);
		},
		spiderifyMapMarkers (clickedMarker, markers, map) {
			let projection = map.getProjection();
			let clickedPos = projection.fromLatLngToPoint(clickedMarker.position);
			let markerWidth = DEFAULT_MARKER_DIMENSIONS;
			let a = markerWidth;
			let b = 0.2 * markerWidth;
			let theta = 0;

			let overlappedMarkers = markers.filter((marker) => {
				if (marker === clickedMarker) { return false; }

				let markerPos = projection.fromLatLngToPoint(marker.position);
				let pixelDistance = Math.sqrt(Math.pow(clickedPos.x - markerPos.x, 2) + Math.pow(clickedPos.y - markerPos.y, 2)) * Math.pow(2, map.zoom);

				return pixelDistance <= markerWidth;
			});

			let spiderMarkers = [ clickedMarker, ...overlappedMarkers ];

			spiderMarkers.forEach((marker, index) => {
				marker.isSpiderPart = true;

				if (index === 0) {
					// keep the clicked marker in place
					marker.position = clickedMarker.position;
				} else {
					// spiral calculation
					let r = a + b * theta;
					let offsetX = r * Math.cos(theta);
					let offsetY = r * Math.sin(theta);
					let x = clickedPos.x + offsetX / Math.pow(2, map.zoom);
					let y = clickedPos.y + offsetY / Math.pow(2, map.zoom);
					let point = new google.maps.Point(x, y);
					let latLng = projection.fromPointToLatLng(point);

					marker.position = new google.maps.LatLng(latLng.lat(), latLng.lng());
					marker.zIndex = 99999;

					// increment angle
					theta += markerWidth / r;
				}
			});
		},
		despiderifyMapMarkers (markers) {
			markers.forEach((m) => {
				let originalPos = originalMapMarkersPos.get(m);

				if (originalPos) {
					m.position = originalPos;
					m.zIndex = 1;
					m.isSpiderPart = false;
				}
			});
		},
		shouldMapMarkersSpiderify (clickedMarker, markers, map) {
			let projection = map.getProjection();
			let clickedPos = projection.fromLatLngToPoint(clickedMarker.position);
			let overlapThreshold = DEFAULT_MARKER_DIMENSIONS / 2;

			return markers.some((marker) => {
				if (marker !== clickedMarker) {
					let markerPos = projection.fromLatLngToPoint(marker.position);
					let pixelDistance = Math.sqrt(Math.pow(clickedPos.x - markerPos.x, 2) + Math.pow(clickedPos.y - markerPos.y, 2)) * Math.pow(2, map.zoom);

					return pixelDistance <= overlapThreshold;
				}

				return false;
			});
		},
	};
</script>
