<link rel="ractive" href="../../r-page-globalping.html" name="r-page">
<link rel="ractive" href="../../components/gp-header.html" name="c-gp-header">
<link rel="ractive" href="../../components/google-maps.html" name="c-google-maps">
<link rel="ractive" href="../../components/gp-footer.html" name="c-gp-footer">
<link rel="ractive" href="../../components/notification.html" name="c-notification">
<link rel="ractive" href="../../components/select.html" name="c-select">

<r-page noYield="{{noYield}}" title="{{title}}" description="{{description}}">
	<c-notification></c-notification>

	<c-gp-header additionalClasses="header-with-globalping-bg"></c-gp-header>

	<div class="p-globalping-network">
		<div class="gp-network">
			<div class="gp-network_map-wrapper">
				<c-google-maps
					class="gp-network_map-wrapper_map"
					iwClass="gp-network_iw"
					probesByCoords="{{filteredMarkersData}}"
					onProbesByCoordsChange="{{@this.handleProbesByCoordsChange}}" />
			</div>

			<div class="gp-network_filters">
				<div class="gp-network_filters_row">
					<div class="gp-network_filters_field gp-network_filters_field--location">
						<label>Location/Network</label>
						<input
							type="text"
							placeholder="Filter by location or network..."
							value="{{locationFilter}}"
							on-input="@this.handleLocationFilter"
						/>
					</div>

					<div class="gp-network_filters_field">
						<label>Group by</label>
						<c-select
							className="gp-network_filters_field--group-by"
							options="{{groupingOptions}}"
							selected="{{groupBy}}" />
					</div>

					<div class="gp-network_filters_field gp-network_filters_field--sort-by">
						<label>Sort by</label>
						<c-select
							options="{{sortOptions}}"
							selected="{{sortOrder}}" />
					</div>
				</div>
				<div class="gp-network_filters_quick_filters">
					<span class="gp-network_filters_quick_filters_title">
						<span>Quick Filters:</span>
					</span>

					<div class="gp-network_filters_quick_filters_list">
						{{#each filtersSet}}
							<span class="gp-network_filters_quick_filters_list_selected">
								{{this.name}}

								<img on-click="@this.rmFilterRule(@key)"
									width="16"
									height="16"
									src="{{@shared.assetsHost}}/img/globalping/tag-input-close-icon.svg">
							</span>
						{{/each}}

						{{#each availableFilters}}
							{{#unless this.selected}}
								<span on-click="@this.setFilterRule(@key)" class="gp-network_filters_quick_filters_list_item">
									{{this.name}}
								</span>
							{{/unless}}
						{{/each}}
					</div>
				</div>
			</div>

			<div class="gp-network_list">
				{{#each preparedProbesColumns as column}}
					<div class="gp-network_list_column">
						{{#each column as continentGroup}}
							<div class="gp-network_list_column_group {{groupBy === 'city-network' || groupBy === 'country-network' ? 'has-networks' : ''}}">
								{{#if continentGroup.title}}
									<span class="gp-network_list_column_group_item cont-header">
										{{@this.getContinentName(continentGroup.title)}}
									</span>
								{{/if}}

								{{#each continentGroup.items as item}}
									<span class="gp-network_list_column_group_item">
										{{#if item.showFlag}}
											<span class="gp-network_list_column_group_item_img">
												<img width="17"
													height="12"
													src="https://cdn.jsdelivr.net/npm/country-flag-icons@1.5.5/3x2/{{item.location.split(', ')[0]}}.svg">
											</span>
										{{/if}}

										<span class="gp-network_list_column_group_item_location">
											{{item.location}}

											{{#if (groupBy !== 'city-network' && groupBy !== 'country-network') && item.probes.length !== 1}}
												<span>(x{{item.probes.length}})</span>
											{{/if}}
										</span>

										{{#if item.networks && item.networks.length}}
											<div class="gp-network_list_column_group_item_networks">
												{{#each item.networks}}
													<span class="gp-network_list_column_group_item_network">
														{{this.name}}
														{{#if this.count !== 1}}
															<span class="gp-network_list_column_group_item_network_count">(x{{this.count}})</span>
														{{/if}}
													</span>
												{{/each}}
											</div>
										{{/if}}
									</span>
								{{/each}}
							</div>
						{{/each}}
					</div>
				{{/each}}

				{{#if preparedProbesColumns && preparedProbesColumns.length === 0}}
					<div class="gp-network_list_no-result">
						No results found. Try adjusting your filters.
					</div>
				{{/if}}
			</div>
		</div>
	</div>

	<c-gp-footer></c-gp-footer>
</r-page>

<script>
	const listeners = require('../../../assets/js/utils/listeners');
	const has = require('../../../assets/js/utils/has');
	const http = require('../../../assets/js/utils/http');
	const CONTINENTS = require('../../../assets/json/continents.json');
	const FILTER_TYPE_BY_CONTINENT = 'byContinent';
	const FILTER_TYPE_BY_NETWORK = 'byNetwork';
	const FILTER_TYPE_BY_CLOUD = 'byCloud';

	component.exports = {
		data () {
			return {
				title: 'Network - Globalping',
				description: 'Explore the global network map of Globalping probes.',
				locationFilter: '',
				availableFilters: [
					{
						name: 'Europe',
						value: 'EU',
						type: FILTER_TYPE_BY_CONTINENT,
					},
					{
						name: 'North America',
						value: 'NA',
						type: FILTER_TYPE_BY_CONTINENT,
					},
					{
						name: 'South America',
						value: 'SA',
						type: FILTER_TYPE_BY_CONTINENT,
					},
					{
						name: 'Africa',
						value: 'AF',
						type: FILTER_TYPE_BY_CONTINENT,
					},
					{
						name: 'Asia',
						value: 'AS',
						type: FILTER_TYPE_BY_CONTINENT,
					},
					{
						name: 'Oceania',
						value: 'OC',
						type: FILTER_TYPE_BY_CONTINENT,
					},
					{
						name: 'eyeball network',
						value: 'eyeball-network',
						type: FILTER_TYPE_BY_NETWORK,
					},
					{
						name: 'datacenter',
						value: 'datacenter-network',
						type: FILTER_TYPE_BY_NETWORK,
					},
					{
						name: 'Google Cloud',
						value: 'gcp',
						type: FILTER_TYPE_BY_CLOUD,
					},
					{
						name: 'AWS Cloud',
						value: 'aws',
						type: FILTER_TYPE_BY_CLOUD,
					},
				],
				groupingOptions: [
					{
						name: 'Country',
						value: 'country',
					},
					{
						name: 'City',
						value: 'city',
					},
					{
						name: 'Network',
						value: 'network',
					},
					{
						name: 'Country + Network',
						value: 'country-network',
					},
					{
						name: 'City + Network',
						value: 'city-network',
					},
					{
						name: 'Disabled',
						value: 'disabled',
					},
				],
				sortOptions: [
					{
						name: 'Ascending',
						value: 'asc',
					},
					{
						name: 'Descending',
						value: 'desc',
					},
				],
				filtersSet: null,
				probesResponse: null,
				probesByContinents: null,
				probesByCoords: null,
				filteredProbes: null,
				preparedProbesColumns: null,
				filteredMarkersData: null,
				groupBy: 'country',
				sortOrder: 'asc',
			};
		},
		computed: {
			filter: {
				get () {
					return this.get('filtersSet') ? this.get('filtersSet').map(f => f.value).join(',').toLowerCase() : [];
				},
				set (filters) {
					let availableFilters = this.get('availableFilters');

					(filters || '').split(',').forEach((f) => {
						let idx = availableFilters.findIndex(af => af.value.toLowerCase() === f.toLowerCase());

						if (idx > -1) {
							this.setFilterRule(idx);
						}
					});
				},
			},
		},
		oninit () {
			if (!Ractive.isServer) {
				// get probes from sessionStorage or fetch them and handle
				this.getProbesData();

				// set initial screenWidth value
				this.observe('screenWidth', (screenWidth) => {
					if (!screenWidth) {
						this.set('screenWidth', window.innerWidth);
					} else {
						let columnsAmount = this.getLayoutColumnsAmount(screenWidth);
						let filteredProbes = this.get('filteredProbes');
						let sorted = this.sortAndGroup(filteredProbes);
						let preparedProbesColumns = this.splitDataIntoColumns(sorted, columnsAmount);

						this.set('preparedProbesColumns', preparedProbesColumns);
					}
				});

				// sort probes by continents, and each list by country name
				this.observe('probesResponse', (probesResponse) => {
					if (probesResponse) {
						let { groupedByContinents, groupedByCoords } = this.groupProbes(probesResponse);

						this.set('probesByContinents', groupedByContinents);
						this.set('probesByCoords', groupedByCoords);

						// set initial probes and marker data values
						let filtersSet = this.get('filtersSet');

						this.set('filteredProbes', this.getFilteredProbesList(filtersSet));
						this.set('filteredMarkersData', this.getFilteredMarkersData(filtersSet));
					}
				});

				// use filters for the probesByContinents before render
				this.observe('filtersSet', (filtersSet) => {
					this.set('filteredProbes', this.getFilteredProbesList(filtersSet));
					this.set('filteredMarkersData', this.getFilteredMarkersData(filtersSet));
				});

				// prepare probes data for rendering
				this.observe('filteredProbes', (filteredProbes) => {
					if (!filteredProbes) { return; }

					let screenWidth = this.get('screenWidth');
					let columnsAmount = this.getLayoutColumnsAmount(screenWidth);

					let sorted = this.sortAndGroup(filteredProbes);
					let preparedProbesColumns = this.splitDataIntoColumns(sorted, columnsAmount);

					this.set('preparedProbesColumns', preparedProbesColumns);
				});

				this.observe('groupBy', () => {
					let screenWidth = this.get('screenWidth');
					let columnsAmount = this.getLayoutColumnsAmount(screenWidth);
					let filteredProbes = this.get('filteredProbes');
					let sorted = this.sortAndGroup(filteredProbes);
					let preparedProbesColumns = this.splitDataIntoColumns(sorted, columnsAmount);

					this.set('preparedProbesColumns', preparedProbesColumns);
				});

				this.observe('sortOrder', () => {
					let screenWidth = this.get('screenWidth');
					let columnsAmount = this.getLayoutColumnsAmount(screenWidth);
					let filteredProbes = this.get('filteredProbes');
					let sorted = this.sortAndGroup(filteredProbes);
					let preparedProbesColumns = this.splitDataIntoColumns(sorted, columnsAmount);

					this.set('preparedProbesColumns', preparedProbesColumns);
				});
			}
		},
		onrender () {
			if (!Ractive.isServer) {
				this.set('@shared.googleMapsLoaded', true);

				listeners.screenWidthListener(this);
			}
		},
		handleProbesByCoordsChange () {
			let filtersSet = this.get('filtersSet');
			let byContinentFilerRule = filtersSet ? filtersSet.find(fR => fR.type === FILTER_TYPE_BY_CONTINENT) : null;

			return byContinentFilerRule;
		},
		getProbesData () {
			if (has.sessionStorage()) {
				let probesResponse = sessionStorage.getItem('probesResponse');

				if (probesResponse) {
					this.handleProbesResponse(true)(probesResponse);
				} else {
					http.fetchGlobalpingProbes().then(this.handleProbesResponse(false));
				}
			} else {
				http.fetchGlobalpingProbes().then(this.handleProbesResponse(false));
			}
		},
		handleProbesResponse (isStored) {
			return (response) => {
				if (!isStored) {
					sessionStorage.setItem('probesResponse', JSON.stringify(response));
				} else {
					response = JSON.parse(response);
				}

				this.set('probesResponse', response);
			};
		},
		groupProbes (probes) {
			// group probes by Continents and Coordinates
			let groups = probes.reduce((res, probe) => {
				let coords = `${probe.location.latitude}, ${probe.location.longitude}`;
				let location = `${probe.location.country}, ${probe.location.city}`;

				// group by Continents
				if (!Object.hasOwn(res.groupedByContinents, probe.location.continent)) {
					res.groupedByContinents[probe.location.continent] = {};
				}

				if (!Object.hasOwn(res.groupedByContinents[probe.location.continent], location)) {
					res.groupedByContinents[probe.location.continent][location] = [];
				}

				res.groupedByContinents[probe.location.continent][location].push(probe);

				// group by Coordinates
				if (!Object.hasOwn(res.groupedByCoords, coords)) {
					res.groupedByCoords[coords] = [];
				}

				res.groupedByCoords[coords].push(probe);

				return res;
			}, {
				groupedByContinents: {},
				groupedByCoords: {},
			});

			let byContinentSorted = Object.entries(groups.groupedByContinents).sort((a, b) => Object.keys(b[1]).length - Object.keys(a[1]).length);
			groups.groupedByContinents = Object.fromEntries(byContinentSorted);
			console.log('groups.groupedByContinents', groups.groupedByContinents);

			return groups;
		},
		getContinentName (code) {
			let cData = CONTINENTS.find(c => c.code === code);

			return cData ? cData.name : null;
		},
		setFilterRule (fIdx) {
			let filtersSet = this.get('filtersSet');
			let availableFilters = this.get('availableFilters');
			let newFilterRule = availableFilters[fIdx];
			let updFiltersSet;

			newFilterRule.selected = true;
			newFilterRule.avFiltersIdx = fIdx;

			if (filtersSet) {
				// if user sets the Eyeball filter we should deselect any byCloud filters and replace the previous byNetwork filter
				if (newFilterRule.value === 'eyeball-network') {
					let { filtered, filteredOut } = filtersSet.reduce((acc, f) => {
						if (f.type !== FILTER_TYPE_BY_CLOUD) {
							acc.filtered.push(f);
						} else {
							acc.filteredOut.push(f);
						}

						return acc;
					}, { filtered: [], filteredOut: [] });

					let index = filtered.findIndex(i => i.type === FILTER_TYPE_BY_NETWORK);

					if (index !== -1) {
						availableFilters[filtered[index].avFiltersIdx].selected = false;
						filtered[index] = newFilterRule;
					} else {
						filtered.push(newFilterRule);
					}

					updFiltersSet = filtered;
					filteredOut.forEach(fO => availableFilters[fO.avFiltersIdx].selected = false);
				// if user sets the byCloud filter we should deselect Eyeball filter and replace the previous byCloud filter
				} else if (newFilterRule.type === FILTER_TYPE_BY_CLOUD) {
					let { filtered, filteredOut } = filtersSet.reduce((acc, f) => {
						if (f.value !== 'eyeball-network') {
							acc.filtered.push(f);
						} else {
							acc.filteredOut.push(f);
						}

						return acc;
					}, { filtered: [], filteredOut: [] });

					let index = filtered.findIndex(i => i.type === FILTER_TYPE_BY_CLOUD);

					if (index !== -1) {
						availableFilters[filtered[index].avFiltersIdx].selected = false;
						filtered[index] = newFilterRule;
					} else {
						filtered.push(newFilterRule);
					}

					updFiltersSet = filtered;
					filteredOut.forEach(fO => availableFilters[fO.avFiltersIdx].selected = false);
				} else if (filtersSet.find(f => f.type === newFilterRule.type)) {
					updFiltersSet = filtersSet.map((f) => {
						if (f.type === newFilterRule.type) {
							availableFilters[f.avFiltersIdx].selected = false;

							return newFilterRule;
						}

						return f;
					});
				} else {
					updFiltersSet = [ ...filtersSet, newFilterRule ];
				}
			} else {
				updFiltersSet = [ newFilterRule ];
			}

			this.set('filtersSet', updFiltersSet);
			this.set('availableFilters', availableFilters);
		},
		rmFilterRule (fIdx) {
			let filtersSet = this.get('filtersSet');
			let availableFilters = this.get('availableFilters');
			let setFilterRule = filtersSet[fIdx];
			let avFiltersRule = availableFilters.find(af => af.value === setFilterRule.value);

			avFiltersRule.selected = false;
			filtersSet.splice(fIdx, 1);

			this.set('filtersSet', filtersSet.length ? filtersSet : []);
			this.set('availableFilters', availableFilters);
		},
		getFilteredProbesList (filtersSet) {
			let probesByContinents = this.get('probesByContinents');

			return this.applyFiltersToData(probesByContinents, filtersSet, true);
		},
		getFilteredMarkersData (filtersSet) {
			let probesByCoords = this.get('probesByCoords');

			return this.applyFiltersToData(probesByCoords, filtersSet);
		},
		applyFiltersToData (data, filtersSet, forProbes = false) {
			let filteredProbes = {};

			if (filtersSet === null || filtersSet.length === 0) {
				return data;
			}

			// get the filter rules
			let byContinentFilerRule = filtersSet.find(fR => fR.type === FILTER_TYPE_BY_CONTINENT);
			let byNetworkFilerRule = filtersSet.find(fR => fR.type === FILTER_TYPE_BY_NETWORK);
			let byCloudFilerRule = filtersSet.find(fR => fR.type === FILTER_TYPE_BY_CLOUD);

			// filter by Continent
			if (byContinentFilerRule) {
				if (forProbes) {
					filteredProbes[byContinentFilerRule.value] = data[byContinentFilerRule.value];
				} else {
					let toFilter = Object.keys(filteredProbes).length ? filteredProbes : data;

					filteredProbes = Object.keys(toFilter).reduce((res, key) => {
						let filtered = toFilter[key].filter(p => p.location.continent === byContinentFilerRule.value);

						if (filtered.length) {
							res[key] = filtered;
						} else {
							delete res[key];
						}

						return res;
					}, filteredProbes);
				}
			}

			// filter by Network
			if (byNetworkFilerRule) {
				let toFilter = Object.keys(filteredProbes).length ? filteredProbes : data;

				if (forProbes) {
					filteredProbes = Object.keys(toFilter).reduce((res, key) => {
						let continentProbes = Object.keys(toFilter[key]).reduce((cRes, loc) => {
							let locFiltered = toFilter[key][loc].filter(p => p.tags.includes(byNetworkFilerRule.value));

							if (locFiltered.length) {
								cRes[loc] = locFiltered;
							}

							return cRes;
						}, {});

						if (Object.keys(continentProbes).length) {
							res[key] = continentProbes;
						} else {
							delete res[key];
						}

						return res;
					}, {});
				} else {
					filteredProbes = Object.keys(toFilter).reduce((res, key) => {
						let filtered = toFilter[key].filter(p => p.tags.includes(byNetworkFilerRule.value));

						if (filtered.length) {
							res[key] = filtered;
						} else {
							delete res[key];
						}

						return res;
					}, filteredProbes);
				}
			}

			// filter by Cloud provider
			if (byCloudFilerRule) {
				let toFilter = Object.keys(filteredProbes).length ? filteredProbes : data;

				if (forProbes) {
					filteredProbes = Object.keys(toFilter).reduce((res, key) => {
						let continentProbes = Object.keys(toFilter[key]).reduce((cRes, loc) => {
							let locFiltered = toFilter[key][loc].filter(p => p.tags.some(v => v.startsWith(byCloudFilerRule.value)));

							if (locFiltered.length) {
								cRes[loc] = locFiltered;
							}

							return cRes;
						}, {});

						if (Object.keys(continentProbes).length) {
							res[key] = continentProbes;
						} else {
							delete res[key];
						}

						return res;
					}, {});
				} else {
					filteredProbes = Object.keys(toFilter).reduce((res, key) => {
						let filtered = toFilter[key].filter(p => p.tags.some(v => v.startsWith(byCloudFilerRule.value)));

						if (filtered.length) {
							res[key] = filtered;
						} else {
							delete res[key];
						}

						return res;
					}, filteredProbes);
				}
			}

			return filteredProbes;
		},
		sortAndGroup (obj) {
			let groupBy = this.get('groupBy');
			let sortOrder = this.get('sortOrder');

			if (groupBy === 'disabled') {
				return [{
					continent: null,
					location: 'Grouping is disabled',
					probes: [],
				}];
			}

			let sortedArray = Object
				.keys(obj)
				.sort((a, b) => a.localeCompare(b))
				.reduce((acc, continent) => {
					let locations = Object.keys(obj[continent]);
					let groupedLocations = locations.reduce((acc, location) => {
						let probes = obj[continent][location];
						let key;

						switch (groupBy) {
							case 'network':
								key = probes[0].location.network;
								break;
							case 'country-network':
								key = probes[0].location.country;
								break;
							case 'city-network':
								key = `${probes[0].location.country}, ${probes[0].location.city}`;
								break;
							case 'city':
								key = `${probes[0].location.country}, ${probes[0].location.city}`;
								break;
							case 'country':
							default:
								key = probes[0].location.country;
								break;
						}

						if (!acc[key]) {
							acc[key] = [];
						}

						acc[key].push(...probes);
						return acc;
					}, {});

					let sortedLocations = Object.keys(groupedLocations).sort((a, b) => {
						if (groupBy === 'network') {
							return a.localeCompare(b);
						}

						let [ countryA, cityA ] = a.split(', ');
						let [ countryB, cityB ] = b.split(', ');

						if (sortOrder === 'asc') {
							return countryA.localeCompare(countryB) || (cityA && cityB ? cityA.localeCompare(cityB) : 0);
						}

						return countryB.localeCompare(countryA) || (cityB && cityA ? cityB.localeCompare(cityA) : 0);
					});

					acc.push(...sortedLocations.map((location) => {
						let probes = groupedLocations[location];
						let networks = [];

						if (groupBy === 'country-network' || groupBy === 'city-network') {
							// Count probes per network
							let networkCounts = probes.reduce((acc, probe) => {
								let network = probe.location.network;
								acc[network] = (acc[network] || 0) + 1;
								return acc;
							}, {});

							// Convert to array of objects with name and count
							networks = Object.entries(networkCounts).map(([ name, count ]) => ({
								name,
								count,
							}));
						}

						return {
							continent,
							location,
							probes,
							networks,
							showFlag: groupBy !== 'network',
						};
					}));

					return acc;
				}, []);

			return sortedArray;
		},
		splitDataIntoColumns (data, columnsCnt = 3, minItemsPerColumn = 30) {
			let totalItems = data.length;
			let itemsPerColumn = Math.max(minItemsPerColumn, Math.ceil(totalItems / columnsCnt));

			let columnNumber = 0;
			let columnMax = Math.max(minItemsPerColumn, itemsPerColumn);

			let groupBy = this.get('groupBy');

			if (groupBy === 'network') {
				return data.reduce((res, item) => {
					if (!res[columnNumber]) {
						res[columnNumber] = [{
							title: null,
							items: [],
						}];
					}

					let currentColumn = res[columnNumber];
					let currentColumnItems = currentColumn[0].items.length;

					if (currentColumnItems >= columnMax) {
						columnNumber++;

						res[columnNumber] = [{
							title: null,
							items: [],
						}];

						currentColumn = res[columnNumber];
					}

					currentColumn[0].items.push(item);
					return res;
				}, []);
			}

			return data.reduce((res, item) => {
				if (!res[columnNumber]) {
					res[columnNumber] = [];
				}

				let currentColumn = res[columnNumber];
				let currentColumnItems = currentColumn.reduce((sum, continent) => {
					return sum + continent.items.length;
				}, 0);

				if (currentColumnItems >= columnMax) {
					columnNumber++;

					if (!res[columnNumber]) {
						res[columnNumber] = [];
					}

					currentColumn = res[columnNumber];
				}

				let continentGroup = currentColumn.find(group => group.title === item.continent);

				if (!continentGroup) {
					continentGroup = {
						title: item.continent,
						items: [],
					};

					currentColumn.push(continentGroup);
				}

				continentGroup.items.push(item);
				return res;
			}, []);
		},
		getLayoutColumnsAmount (screenWidth) {
			let columnsAmount = 1;

			if (screenWidth >= 576 && screenWidth < 992) {
				columnsAmount = 2;
			} else if (screenWidth >= 992) {
				columnsAmount = 3;
			}

			return columnsAmount;
		},
	};
</script>
