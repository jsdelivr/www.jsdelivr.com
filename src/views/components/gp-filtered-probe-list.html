<link rel="ractive" href="./select.html" name="c-select">
<link rel="ractive" href="./location-input.html" name="c-location-input">
<link rel="ractive" href="./probe-single-card.html" name="c-probe-single-card">

<div class="gp-filtered-list">
	<div class="gp-filtered-list_filters">
		<div class="gp-filtered-list_filters_row">
			<div class="gp-filtered-list_filters_field gp-filtered-list_filters_field--location">
				<c-location-input
					rawProbes="{{rawProbes}}"
					value="{{location}}"
					error="{{locationError}}"
					placeholder="Enter location"
					labelText="Location"
					classList="gp_map-block_settings-wrapper_settings_location gp_input"
					ttPos="{{ttPositions.locationTtPos}}"
					exposeProbes="{{true}}"
					results="{{locationProbes}}"
					completedValue="{{locationCompletedValue}}">
					{{#partial labelIcon}}
						<img as-tooltip="[ 'This magic field supports names of continents, regions, countries, US states, cities, networks, and our custom tags.', '', 'Use + to combine multiple filters.', 'Use , to select multiple locations.' ], ttPos, undefined, undefined, 'multiline'"
							width="14"
							height="14"
							src="{{@shared.assetsHost}}/img/globalping/help-icon.svg"
						>
					{{/partial}}
				</c-location-input>
			</div>

			<div class="gp-filtered-list_filters_field gp-filtered-list_filters_field--group-by">
				<label>Group by</label>
				<c-select
					options="{{groupingOptions}}"
					selected="{{groupBy}}"
					name="group-by-select"
				/>
			</div>

			<div class="gp-filtered-list_filters_field gp-filtered-list_filters_field--sort-by">
				<label>Sort by</label>
				<c-select
					options="{{sortOptions}}"
					disabled="{{groupBy === 'disabled'}}"
					selected="{{sortOrder}}"
					name="sort-by-select"
				/>
			</div>
		</div>
		<div class="gp-filtered-list_filters_quick">
            <span class="gp-filtered-list_filters_quick_title">
                <span>Quick Filters:</span>
            </span>

			<div class="gp-filtered-list_filters_quick_list">
				{{#each filtersSet}}
					<span class="gp-filtered-list_filters_quick_list_selected">
                        {{this.name}}
                        <button on-click="@this.rmFilterRule(@key)"
                            type="button"
                            class="gp-filtered-list_filters_quick_list_selected_remove">
                            <img width="16" height="16" src="{{@shared.assetsHost}}/img/globalping/tag-input-close-icon.svg">
                        </button>
                    </span>
				{{/each}}

				{{#each availableFilters}}
					{{#unless this.selected}}
						<button on-click="@this.setFilterRule(@key)"
							type="button"
							class="gp-filtered-list_filters_quick_list_item">
							{{this.name}}
						</button>
					{{/unless}}
				{{/each}}
			</div>
		</div>
	</div>

	{{#if probeContinents.length > 1}}
		<div class="gp-filtered-list_jump">
			<div class="gp-filtered-list_jump_field">
				<label>Jump to</label>
				<c-select
						options="{{probeContinents}}"
						selected="{{selectedContinent}}"
						placeholder="Choose continent"
						onSelect="{{@this.scrollToContinent}}"
						name="jump-to-select"
				/>
			</div>
		</div>
	{{/if}}

	<div class="gp-filtered-list_list {{groupBy === 'disabled' ? 'disabled-group-by' : ''}}">
		{{#if probesLoading}}
			<div class="gp-filtered-list_list_loading">
				Loading...
			</div>
		{{elseif probesError}}
			<div class="gp-filtered-list_list_error">
				Failed to load probes. Please try again later.
				<button type="button" on-click="refresh()">Try again</button>
			</div>
		{{else}}
			{{#if preparedProbesColumns && preparedProbesColumns.length === 0}}
				<div class="gp-filtered-list_list_no-result">
					{{#if rawProbes && rawProbes.length}}
					No results found. Try adjusting your filters.
					{{else}}
					No probes found.
					{{/if}}
				</div>
			{{else}}
				{{#each preparedProbesColumns as column}}
					<div class="gp-filtered-list_list_column {{groupBy === 'disabled' ? 'disabled-group-by' : ''}}">
						{{#if groupBy === 'disabled'}}
							{{#each column as continentGroup}}
								{{#each continentGroup.items as item}}
									<c-probe-single-card location="{{item.location}}" tags="{{item.tags}}" maxTagCount="{{maxTagCount}}"></c-probe-single-card>
								{{/each}}
							{{/each}}
						{{else}}
							{{#each column as continentGroup}}
								<div class="gp-filtered-list_list_column_group {{groupBy === 'city-network' || groupBy === 'country-network' ? 'has-networks' : ''}}">
									{{#if continentGroup.title}}
										<span class="gp-filtered-list_list_column_group_item cont-header" id="probe-group-{{continentGroup.title}}">
                                            {{@this.getContinentName(continentGroup.title)}}
                                        </span>
									{{/if}}

									{{#each continentGroup.items as item}}
										<span class="gp-filtered-list_list_column_group_item">
                                            {{#if item.showFlag}}
                                                <span class="gp-filtered-list_list_column_group_item_img">
                                                    <img width="17"
                                                         height="12"
                                                         src="https://cdn.jsdelivr.net/npm/country-flag-icons@1.5.5/3x2/{{item.location.split(', ')[0]}}.svg">
                                                </span>
                                            {{/if}}

                                            <span class="gp-filtered-list_list_column_group_item_location">
                                                <a href="/?location={{encodeURIComponent(item.from)}}">{{item.name}}</a>

                                                {{#if (groupBy !== 'city-network' && groupBy !== 'country-network') && item.probes.length !== 1}}
                                                    <span>(x{{item.probes.length}})</span>
                                                {{/if}}
                                            </span>

                                            {{#if item.networks && item.networks.length}}
                                                <div class="gp-filtered-list_list_column_group_item_networks">
                                                    {{#each item.networks}}
                                                        <a href="/?location={{encodeURIComponent(`${item.from}%${this.name}`)}}">
                                                            <span class="gp-filtered-list_list_column_group_item_network">
                                                                {{this.name}}
                                                                {{#if this.count !== 1}}
                                                                    <span class="gp-filtered-list_list_column_group_item_network_count">(x{{this.count}})</span>
                                                                {{/if}}
                                                            </span>
                                                        </a>
                                                    {{/each}}
                                                </div>
                                            {{/if}}
                                        </span>
									{{/each}}
								</div>
							{{/each}}
						{{/if}}
					</div>
				{{/each}}
			{{/if}}
		{{/if}}
	</div>
</div>

<script>
	const _ = require('../../assets/js/_');
	const debounce = require('../../assets/js/utils/debounce');
	const throttle = require('../../assets/js/utils/throttle');
	const listeners = require('../../assets/js/utils/listeners');

	const CONTINENTS = require('../../assets/json/continents.json');
	const COUNTRIES = require('../../assets/json/countries.json');
	const FILTER_TYPE_BY_CONTINENT = 'byContinent';
	const FILTER_TYPE_BY_NETWORK = 'byNetwork';

	const CONTINENT_MAP = CONTINENTS.reduce((acc, continent) => {
		acc[continent.code] = continent.name;
		return acc;
	}, {});

	const COUNTRIES_MAP = COUNTRIES.reduce((acc, country) => {
		acc[country.code] = country.name;
		return acc;
	}, {});

	component.exports = {
		data () {
			return {
				_,
				locationError: '',
				availableFilters: [
					{
						name: 'Europe',
						value: 'Europe',
						type: FILTER_TYPE_BY_CONTINENT,
					},
					{
						name: 'North America',
						value: 'North America',
						type: FILTER_TYPE_BY_CONTINENT,
					},
					{
						name: 'South America',
						value: 'South America',
						type: FILTER_TYPE_BY_CONTINENT,
					},
					{
						name: 'Africa',
						value: 'Africa',
						type: FILTER_TYPE_BY_CONTINENT,
					},
					{
						name: 'Asia',
						value: 'Asia',
						type: FILTER_TYPE_BY_CONTINENT,
					},
					{
						name: 'Oceania',
						value: 'Oceania',
						type: FILTER_TYPE_BY_CONTINENT,
					},
					{
						name: 'eyeball network',
						value: 'eyeball-network',
						type: FILTER_TYPE_BY_NETWORK,
					},
					{
						name: 'datacenter',
						value: 'datacenter-network',
						type: FILTER_TYPE_BY_NETWORK,
					},
				],
				groupingOptions: [
					{
						name: 'Country',
						value: 'country',
					},
					{
						name: 'City',
						value: 'city',
					},
					{
						name: 'Network',
						value: 'network',
					},
					{
						name: 'Country + Network',
						value: 'country-network',
					},
					{
						name: 'City + Network',
						value: 'city-network',
					},
					{
						name: 'Disabled',
						value: 'disabled',
					},
				],
				sortOptions: [
					{
						name: 'Alphabetically',
						value: 'alphabetically',
					},
					{
						name: 'Probe count',
						value: 'probe-count',
					},
				],
				probeContinents: [],
				filtersSet: null,
				groupedProbes: null,
				locationProbes: null,
				preparedProbesColumns: null,
				filteredMarkersData: null,
				selectedContinent: null,
				maxTagCount: 2,
			};
		},
		oninit () {
			if (!Ractive.isServer) {
				// set initial screenWidth value
				this.observe('screenWidth', (screenWidth) => {
					if (!screenWidth) {
						this.set('screenWidth', window.innerWidth);
						return;
					}

					let preparedProbesColumns = this.splitDataIntoColumns();
					this.set('preparedProbesColumns', preparedProbesColumns);

					// handle tooltips positions depending on the screen size
					let ttPositions = {};

					if (screenWidth >= 1272) {
						ttPositions.targetTtPos = 'top';
						ttPositions.locationTtPos = 'top';
						ttPositions.limitTtPos = 'top';
					} else if (screenWidth >= 768) {
						ttPositions.targetTtPos = 'top';
						ttPositions.locationTtPos = 'right';
						ttPositions.limitTtPos = 'top';
					} else {
						ttPositions.targetTtPos = 'right';
						ttPositions.locationTtPos = 'right';
						ttPositions.limitTtPos = 'right';
					}

					this.set('ttPositions', ttPositions);
				});

				this.observe('location', () => {
					this.updateFiltersSet();
				});

				this.observe('locationProbes', (locationProbes) => {
					let groupedProbes = this.groupProbes(locationProbes || []);

					this.set('groupedProbes', groupedProbes);
					this.set('filteredProbes', locationProbes);
				});

				this.observe('groupBy', () => {
					let locationProbes = this.get('locationProbes');
					let groupedProbes = this.groupProbes(locationProbes || []);

					this.set('groupedProbes', groupedProbes);

					let preparedProbesColumns = this.splitDataIntoColumns();
					this.set('preparedProbesColumns', preparedProbesColumns);
				});

				this.observe('groupedProbes', () => {
					this.calculateMaxTagCount();
					this.recalculateProbeContinents();
				});

				this.observe('sortOrder groupedProbes', () => {
					let preparedProbesColumns = this.splitDataIntoColumns();
					this.set('preparedProbesColumns', preparedProbesColumns);
				});
			}
		},
		onrender () {
			if (!Ractive.isServer) {
				let handleResize = debounce(throttle(() => this.calculateMaxTagCount(), 200));
				listeners.addManagedListener(this, window, 'resize', handleResize);
				listeners.screenWidthListener(this);
			}
		},
		groupProbes (probes) {
			let groupBy = this.get('groupBy');
			// group probes by Continents and Coordinates
			let groups = probes.reduce((res, probe) => {
				let location = `${probe.location.country}, ${probe.location.city}`;

				let groupKey = groupBy === 'disabled' ? 'disabled' : probe.location.continent;


				if (groupBy === 'disabled') {
					if (!Object.hasOwn(res, groupKey)) {
						res[groupKey] = [];
					}

					res[groupKey].push(probe);
				} else {
					if (!Object.hasOwn(res, groupKey)) {
						res[groupKey] = {};
					}

					if (!Object.hasOwn(res[groupKey], location)) {
						res[groupKey][location] = [];
					}

					res[groupKey][location].push(probe);
				}

				return res;
			}, {});

			if (groupBy !== 'disabled') {
				let byContinentSorted = Object.entries(groups).sort((a, b) => Object.keys(b[1]).length - Object.keys(a[1]).length);
				groups = Object.fromEntries(byContinentSorted);
			}

			return groups;
		},
		getContinentName (code) {
			return CONTINENT_MAP[code] || code;
		},
		getCountryName (code) {
			return COUNTRIES_MAP[code] || code;
		},
		updateFiltersSet () {
			let location = this.get('location');
			let availableFilters = this.get('availableFilters');
			availableFilters.forEach(f => f.selected = false);

			if (!location) {
				this.set('filtersSet', []);
				this.set('availableFilters', availableFilters);
				return;
			}

			let parts = location.split(/[+,]/).map(p => p.trim().toLowerCase());
			let filtersSet = [];

			availableFilters.forEach((f, i) => {
				let part = parts.find((part) => {
					return f.name.toLowerCase() === part || f.value.toLowerCase() === part;
				});

				if (part) {
					f.selected = true;
					f.avFiltersIdx = i;
					filtersSet.push(f);
				}
			});

			this.set('filtersSet', filtersSet);
			this.set('availableFilters', availableFilters);
		},
		setFilterRule (idx) {
			let availableFilters = this.get('availableFilters');
			let selectedFilter = availableFilters[idx];
			let location = this.get('location');

			if (!location) {
				this.set('location', selectedFilter.value);
			} else {
				let parts = location.split(',').map(query => query.split('+').map(p => p.trim().toLowerCase())).flat();
				let hasContinent = false;
				let hasNetwork = false;

				for (let f of availableFilters) {
					let matchingPart = parts.find(part => part === f.name.toLowerCase() || part === f.value.toLowerCase());

					if (matchingPart) {
						if (f.type === FILTER_TYPE_BY_CONTINENT) {
							hasContinent = true;
						} else if (f.type === FILTER_TYPE_BY_NETWORK) {
							hasNetwork = true;
						}
					}
				}

				if (selectedFilter.type === FILTER_TYPE_BY_NETWORK && hasContinent && !hasNetwork) {
					this.set('location', `${location}+${selectedFilter.value}`);
				} else if (selectedFilter.type === FILTER_TYPE_BY_CONTINENT && hasNetwork && !hasContinent) {
					this.set('location', `${location}+${selectedFilter.value}`);
				} else {
					this.set('location', selectedFilter.value);
				}
			}

			this.findComponent('c-location-input')?.fire('outsideLocationChange');
		},
		rmFilterRule (idx) {
			let filter = this.get('filtersSet')[idx];
			let selectedFilter = this.get('availableFilters').find(f => f.value === filter.value);
			let location = this.get('location');

			if (location.includes(selectedFilter.value)) {
				let parts = location.split(',');
				let updatedParts = parts.map((part) => {
					let segments = part.split('+').map(s => s.trim());
					let filteredSegments = segments.filter(s => s.toLowerCase() !== filter.value.toLowerCase());
					return filteredSegments.join('+');
				}).filter(part => part.trim() !== '');

				this.set('location', updatedParts.join(',') || 'World');
			}

			this.findComponent('c-location-input')?.fire('outsideLocationChange');
		},
		sortAndGroup (obj) {
			let groupBy = this.get('groupBy');
			let sortOrder = this.get('sortOrder');

			if (groupBy === 'disabled') {
				return Object.values(obj).flat();
			}

			if (groupBy === 'network') {
				let allNetworks = {};

				Object.keys(obj).forEach((continent) => {
					let locations = Object.keys(obj[continent]);
					locations.forEach((location) => {
						let probes = obj[continent][location];
						probes.forEach((probe) => {
							let network = probe.location.network;
							let key = network.toLowerCase();

							if (!Object.hasOwn(allNetworks, key)) {
								allNetworks[key] = {
									name: network,
									probes: [],
								};
							}

							allNetworks[key].probes.push(probe);
						});
					});
				});

				let sortedNetworks = Object.keys(allNetworks).sort((a, b) => {
					if (sortOrder === 'alphabetically') {
						return allNetworks[a].name.localeCompare(allNetworks[b].name);
					}

					return allNetworks[b].probes.length - allNetworks[a].probes.length;
				});

				return sortedNetworks.map(network => ({
					continent: null,
					name: allNetworks[network].name,
					from: allNetworks[network].name,
					location: allNetworks[network].name,
					probes: allNetworks[network].probes,
					networks: [],
					showFlag: false,
				}));
			}

			let networkNameMap = {}; // make sure all networks have the same letter case across cities/countries

			let sortedArray = Object
				.keys(obj)
				.sort((a, b) => {
					if (sortOrder === 'alphabetically') {
						return a.localeCompare(b);
					}

					let probesCountA = Object.values(obj[a]).reduce((sum, probes) => sum + probes.length, 0);
					let probesCountB = Object.values(obj[b]).reduce((sum, probes) => sum + probes.length, 0);
					return probesCountB - probesCountA;
				})
				.reduce((acc, continent) => {
					let locations = Object.keys(obj[continent]);
					let groupedLocations = locations.reduce((acc, location) => {
						let probes = obj[continent][location];
						let key;

						switch (groupBy) {
							case 'country-network':
								key = probes[0].location.country;
								break;
							case 'city-network':
								key = `${probes[0].location.country}, ${probes[0].location.city}`;
								break;
							case 'city':
								key = `${probes[0].location.country}, ${probes[0].location.city}`;
								break;
							case 'country':
							default:
								key = probes[0].location.country;
								break;
						}

						if (!acc[key]) {
							acc[key] = [];
						}

						acc[key].push(...probes);
						return acc;
					}, {});

					let sortedLocations = Object.keys(groupedLocations).sort((a, b) => {
						let [ countryA, cityA ] = a.split(', ');
						let [ countryB, cityB ] = b.split(', ');

						if (sortOrder === 'alphabetically') {
							return countryA.localeCompare(countryB) || (cityA && cityB ? cityA.localeCompare(cityB) : 0);
						}

						return groupedLocations[b].length - groupedLocations[a].length;
					});

					acc.push(...sortedLocations.map((location) => {
						let probes = groupedLocations[location];
						let networks = [];

						if (groupBy === 'country-network' || groupBy === 'city-network') {
							// Count probes per network
							let networkCounts = probes.reduce((acc, probe) => {
								let network = probe.location.network;
								let key = network.toLowerCase();

								if (!Object.hasOwn(networkNameMap, key)) {
									networkNameMap[key] = network;
								}

								if (!Object.hasOwn(acc, key)) {
									acc[key] = {
										name: networkNameMap[key],
										count: 0,
									};
								}

								acc[key].count += 1;
								return acc;
							}, {});

							networks = Object.entries(networkCounts).map(([ , { name, count }]) => ({
								name,
								count,
							}));

							if (sortOrder === 'alphabetically') {
								networks.sort((a, b) => a.name.localeCompare(b.name));
							} else {
								networks.sort((a, b) => b.count - a.count);
							}
						}

						let from;

						switch (groupBy) {
							case 'city':
							case 'city-network':
								from = `${probes[0].location.city}%${probes[0].location.country}`;
								break;
							case 'country-network':
							case 'country':
							default:
								from = this.getCountryName(probes[0].location.country);
								break;
						}

						return {
							continent,
							from,
							name: groupBy.startsWith('country') ? this.getCountryName(location) : location,
							location,
							probes,
							networks,
							showFlag: groupBy !== 'network',
						};
					}));

					return acc;
				}, []);

			return sortedArray;
		},
		splitDataIntoColumns () {
			let minItemsPerColumn = this.get('groupBy') === 'disabled' ? 1 : 10;
			let groupedProbes = this.get('groupedProbes');

			if (!groupedProbes) {
				return [];
			}

			let data = this.sortAndGroup(groupedProbes);

			let screenWidth = this.get('screenWidth');
			let columnsCnt = this.getLayoutColumnsAmount(screenWidth);

			let groupBy = this.get('groupBy');
			let totalItems = data.length + (groupBy.includes('-network') ? data.reduce((sum, item) => sum + Math.ceil(item.networks.length * .75), 0) : 0);
			let itemsPerColumn = Math.max(minItemsPerColumn, Math.ceil(totalItems / columnsCnt));
			let columnMax = Math.max(minItemsPerColumn, itemsPerColumn);
			let columnNumber = 0;

			if (groupBy === 'network' || groupBy === 'disabled') {
				return data.reduce((res, item) => {
					if (!res[columnNumber]) {
						res[columnNumber] = [{
							title: null,
							items: [],
						}];
					}

					let currentColumn = res[columnNumber];
					let currentColumnItems = currentColumn[0].items.length;

					if (currentColumnItems >= columnMax) {
						columnNumber++;

						res[columnNumber] = [{
							title: null,
							items: [],
						}];

						currentColumn = res[columnNumber];
					}

					currentColumn[0].items.push(item);
					return res;
				}, []);
			}

			let currentColumnItems = 0;
			return data.reduce((res, item) => {
				if (!res[columnNumber]) {
					res[columnNumber] = [];
				}

				let currentColumn = res[columnNumber];
				let itemsHeight = 1 + (groupBy.includes('-network') ? Math.ceil(item.networks.length * .75) : 0);

				if (
					columnNumber < columnsCnt - 1
					&& (currentColumnItems >= columnMax
						|| (currentColumnItems > 0 && currentColumnItems + (itemsHeight * .5) > columnMax)
					)
				) {
					columnNumber++;

					if (!res[columnNumber]) {
						res[columnNumber] = [];
					}

					currentColumn = res[columnNumber];
					currentColumnItems = 0;
				}

				let continentGroup = currentColumn.find(group => group.title === item.continent);

				if (!continentGroup) {
					continentGroup = {
						title: item.continent,
						items: [],
					};

					currentColumn.push(continentGroup);
				}

				continentGroup.items.push(item);
				currentColumnItems += groupBy.includes('-network') ? 1 + Math.ceil(item.networks.length * .75) : 1;

				return res;
			}, []);
		},
		getLayoutColumnsAmount (screenWidth) {
			let columnsAmount = 1;

			if (this.get('groupBy') === 'disabled') {
				if (screenWidth >= 992) {
					columnsAmount = 2;
				}
			} else if (screenWidth >= 576 && screenWidth < 992) {
				columnsAmount = 2;
			} else if (screenWidth >= 992) {
				columnsAmount = 3;
			}

			return columnsAmount;
		},
		recalculateProbeContinents () {
			let groupBy = this.get('groupBy');
			let groupedProbes = this.get('groupedProbes');

			if (groupBy === 'disabled' || groupBy === 'network') {
				this.set('probeContinents', []);
				this.set('selectedContinent', null);
			} else {
				this.set('probeContinents', Object.keys(groupedProbes).map(continent => ({
					name: this.getContinentName(continent),
					value: continent,
				})));

				let selectedContinent = this.get('selectedContinent');
				this.set(
					'selectedContinent',
					this.get('probeContinents')
						.some(c => c.value === selectedContinent) ? selectedContinent : null,
				);
			}
		},
		calculateMaxTagCount () {
			if (this.get('groupBy') !== 'disabled') {
				return;
			}

			let tagContainer = $('.probe-single-card_tag').get(0);
			let tagContainerWidth = tagContainer ? tagContainer.offsetWidth : 0;
			let maxTagCount = Math.max(2, Math.floor(tagContainerWidth / 100));
			this.set('maxTagCount', maxTagCount);
		},
		scrollToContinent (continent) {
			let continentElement = document.getElementById(`probe-group-${continent}`);

			if (continentElement) {
				continentElement.scrollIntoView({ behavior: 'smooth' });
			}
		},
	};
</script>
