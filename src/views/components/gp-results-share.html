<div class="c-gp-results-share">
	<div class="c-gp-results-share_content">
		<button as-clipboard data-clipboard-text="{{measurementLink}}">
			<img width="20" height="20" src="{{@shared.assetsHost}}/img/globalping/url-icon.svg">
			Copy URL
		</button>

		<button as-clipboard data-clipboard-text="{{markdownResults}}">
			<img width="20" height="20" src="{{@shared.assetsHost}}/img/globalping/markdown-icon.svg">
			Copy Markdown
		</button>

		<div class="c-gp-results-share_content_command">
			<span class="c-gp-results-share_content_command_label">
				<i class="fa fa-terminal" aria-hidden="true"></i>
				<span>Replicate in CLI</span>
			</span>

			<span id="share-res-text" class="c-gp-results-share_content_command_value">
				{{cliCommand}}
			</span>

			<button as-clipboard data-clipboard-text="{{cliCommand}}">
				<img width="20" height="20" src="{{@shared.assetsHost}}/img/globalping/copy-icon-black.svg">
			</button>
		</div>
	</div>

	{{#if shareResMsg}}
		<div class="c-gp-results-share_warning">{{shareResMsg}}</div>
	{{/if}}
</div>


<script>
	const _ = require('../../assets/js/_');
	const PROBE_STATUS_OFFLINE = _.getProbeStatusOfflineValue();
	const clipboard = require('../../assets/js/decorators/clipboard');
	const { addManagedListener } = require('../../assets/js/utils/listeners');

	component.exports = {
		decorators: {
			clipboard,
		},
		data () {
			return {
				shareResMsg: '',
				markdownResults: '',
				measurementLink: '',
				cliCommand: '',
			};
		},
		onrender () {
			if (!Ractive.isServer) {
				addManagedListener(this, window, 'historyChange', this.createMeasLink.bind(this));

				// select all share-res text of link on click
				this.observe('testInProgress', (testInProgress) => {
					if (!testInProgress) {
						let shareResTextEl = this.find('#share-res-text');

						shareResTextEl.addEventListener('click', () => {
							window.getSelection().selectAllChildren(shareResTextEl);
						});
					}
				}, { defer: true });

				this.observe('isInfiniteModeRes measurementsMetadata', () => {
					this.createMeasLink();
				});

				this.observe('isInfiniteModeRes measurementsMetadata testReqParams', () => {
					this.createCliCommand();
				});

				this.observe('preparedTestResults testReqParams measurementsMetadata measurementLink', () => {
					this.createMarkdownResults();
				});
			}
		},
		createMeasLink () {
			let measurementsMetadata = this.get('measurementsMetadata');
			let isInfiniteModeRes = this.get('isInfiniteModeRes');

			let origin = this.get('@global.location.origin');
			// regular measurement IDs should be separated by a comma
			let idsDelimiter = ',';
			let measIDsArr = Object.values(measurementsMetadata).map(v => v.measurementId);
			let preparedMeasIDsArr = measIDsArr;

			this.set('shareResMsg', '');

			if (isInfiniteModeRes) {
				// the infinite one by a dot
				idsDelimiter = '.';

				// for infinite get last 10 IDs from oldest to newest
				preparedMeasIDsArr = measIDsArr.slice(-10);

				// show related message for such case
				if (measIDsArr.length >= 10) {
					this.set('shareResMsg', 'For long-running continuous mode measurements, only the last 160 packets are shared via URL.');
				}
			}

			let textToCopy = preparedMeasIDsArr.join(idsDelimiter);

			let urlSearchParams = new URLSearchParams(location.search);
			urlSearchParams.set('measurement', textToCopy);

			this.set('measurementLink', `${origin}?${urlSearchParams.toString()}`);
		},
		createCliCommand () {
			let params = this.get('testReqParams');
			let measurementsMetadata = this.get('measurementsMetadata');
			let targetsCnt = Object.values(measurementsMetadata).map(v => v.target).length;
			let isInfiniteModeRes = this.get('isInfiniteModeRes');

			if (targetsCnt >= 2 && !isInfiniteModeRes) {
				this.set('cliCommand', 'Not supported yet');
				return;
			}

			let cmd = Object.keys(params).reduce((cmd, key) => {
				// test type part
				if (key === 'type') {
					cmd.typePart += ` ${params[key]} ${params.target}`;

					if (params.locations && params.locations.length) {
						let locationStr = params.locations.reduce((str, loc, idx) => {
							let locPart = loc.magic.trim();

							if (idx === 0) {
								return str += locPart;
							}

							return str += `, ${locPart}`;
						}, '');

						cmd.typePart += ` from ${locationStr}`;
					}

					if (params.measurementOptions) {
						let str = Object.keys(params.measurementOptions).reduce((str, key) => {
							switch (key) {
								case 'packets':
									str += ` --packets ${params.measurementOptions.packets}`; break;

								case 'port':
									str += ` --port ${params.measurementOptions.port}`; break;

								case 'protocol':
									str += ` --protocol ${params.measurementOptions.protocol}`; break;

								case 'type':
									str += ` --type ${params.measurementOptions.type}`; break;

								case 'trace':
									if (params.type.toLowerCase() === 'dns' && params.measurementOptions.trace) {
										str += ' --trace';
									}

									break;

								case 'resolver':
									str += ` --resolver ${params.measurementOptions.resolver}`; break;

								case 'request':
									if (params.measurementOptions.request.host) {
										str += ` --host ${params.measurementOptions.request.host}`;
									}

									if (params.measurementOptions.request.path) {
										let path = params.measurementOptions.request.path;

										path = path[0] === '/' ? path : `/${path}`;
										str += ` --path '${path}'`;
									}

									if (params.measurementOptions.request.query) {
										str += ` --query '${params.measurementOptions.request.query}'`;
									}

									if (params.measurementOptions.request.method) {
										str += ` --method ${params.measurementOptions.request.method}`;
									}

									break;
							}

							return str;
						}, '');

						cmd.typePart += str;
					}
				}

				// global flags part
				if (key === 'limit') {
					cmd.globalPart += ` --limit ${params[key]}`;
				}

				return cmd;
			}, {
				base: 'globalping',
				typePart: '',
				globalPart: '',
			});

			// add infinite flag for the Infinite flow
			if (isInfiniteModeRes) {
				cmd.globalPart += ' --infinite';
			}

			this.set('cliCommand', cmd.base + cmd.typePart + cmd.globalPart);
		},
		createMarkdownResults () {
			let results = this.get('preparedTestResults');
			let testReqParams = this.get('testReqParams');
			let measurementsMetadata = this.get('measurementsMetadata');

			// create result title consisting of the test type and locations
			let locationStr = testReqParams.locations.map(location => Object.values(location).join('+').trim()).join(', ');

			let testMethod = testReqParams.measurementOptions?.request?.method;
			let dnsTestType = testReqParams.measurementOptions?.query?.type;
			let extraTestInfo = testMethod || dnsTestType;

			let testType = testReqParams.type.toUpperCase();
			let testStr = `${testType}${extraTestInfo ? ` (${extraTestInfo})` : ''}`;
			let resultTitle = `## Globalping: \`${testStr}\` from ${locationStr}\n`;

			// create markdown for each target
			let targetStrings = [];
			let targetNames = Array.from(new Set(Object.values(measurementsMetadata).map(m => m.target)));

			for (let targetIdx = 0; targetIdx < targetNames.length; ++targetIdx) {
				// add target header and iterate over each result (probe)
				let currentTarget = targetNames[targetIdx];
				let targetHeader = `### Target: ${currentTarget}\n\n`;

				let perProbe = results.map((probeStats) => {
					let targetStats = probeStats.statsPerTarget.find(measurement => measurement.target === currentTarget);

					if (!targetStats) {
						return '';
					}

					// HEADER
					let header = `#### ${probeStats.city}, ${probeStats.country}, ${probeStats.continent} - ${probeStats.network} (AS${probeStats.asn})\n`;

					// SUBHEADER (timing etc.)
					let subheaderParts = [];
					let timing = _.getGpTargetTiming(targetStats);

					if (timing) {
						subheaderParts.push({ title: 'Time', value: timing });
					}

					if (!targetStats.isFailed && targetStats.avgTiming !== PROBE_STATUS_OFFLINE) {
						Object.keys(targetStats.extraValues).forEach((key) => {
							let extraVal = targetStats.extraValues[key];
							subheaderParts.push({ title: extraVal.text, value: `${extraVal.value}${extraVal.units}` });
						});
					}

					if (testReqParams.type === 'http' && targetStats.ipAddr) {
						subheaderParts.push({ title: 'Resolved address', value: targetStats.ipAddr });
					}

					let subheader = subheaderParts.map(({ title, value }) => `${title}: \`${value}\``).join('&nbsp;&nbsp;&nbsp;');

					if (subheader) {
						subheader += '\n';
					}

					// RAW OUTPUT
					let rawOutputContent = targetStats.rawOutput.trim();
					let tickCount = 3;

					for (let tickSequence of rawOutputContent.matchAll(/`+/g)) {
						tickCount = Math.max(tickCount, tickSequence[0].length + 1);
					}

					let tickWrapper = '`'.repeat(tickCount);
					let rawOutputBlock = `${tickWrapper}\n${rawOutputContent}\n${tickWrapper}`;

					// COMPLETE THE STRING
					return `${header}${subheader}${rawOutputBlock}`;
				}).join('\n\n');

				targetStrings.push(targetHeader + perProbe);
			}

			let targetStr = targetStrings.join('\n\n---\n\n');
			let link = this.get('measurementLink');
			let footer = link ? `\n\nYou can also view the results at ${link}\n` : '';
			this.set('markdownResults', resultTitle + targetStr + footer);
		},
	};
</script>
